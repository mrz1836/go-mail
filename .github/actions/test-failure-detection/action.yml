# ------------------------------------------------------------------------------------
#  Test Failure Detection (Composite Action)
#
#  Purpose: Define and provide reusable test failure detection functions for
#  robust test output parsing across different formats and test types.
#
#  This action provides sophisticated failure detection capabilities:
#    - JSON-based test output parsing (fast single-pass)
#    - Text-based failure detection with multiple patterns
#    - Detailed error capture and context preservation
#    - Fallback detection for edge cases
#
#  Maintainer: @mrz1836
#
# ------------------------------------------------------------------------------------

name: "Test Failure Detection"
description: "Provides robust test failure detection functions for JSON and text output parsing"

inputs:
  output-file:
    description: "Test output file to analyze"
    required: false
    default: "test-output.log"
  exit-code:
    description: "Test command exit code"
    required: false
    default: "0"
  mode:
    description: "Detection mode (json or text)"
    required: false
    default: "text"
  failures-file:
    description: "Output file for detected failures"
    required: false
    default: "test-failures.txt"

outputs:
  failure-count:
    description: "Number of detected test failures"
    value: ${{ steps.detect-failures.outputs.failure-count }}
  has-failures:
    description: "Boolean indicating if failures were detected"
    value: ${{ steps.detect-failures.outputs.has-failures }}
  detailed-failures-file:
    description: "Path to detailed failures file"
    value: ${{ steps.detect-failures.outputs.detailed-failures-file }}

runs:
  using: "composite"
  steps:
    - name: üîß Define failure detection functions
      shell: bash
      run: |
        # Define reusable function for robust test failure detection
        cat > test-failure-functions.sh << 'DETECTION_FUNCTIONS_EOF'
        #!/bin/bash

        # Robust test failure detection function
        detect_test_failures() {
          local output_file="$1"
          local exit_code="${2:-0}"
          local mode="${3:-text}"
          local failures_file="${4:-test-failures.txt}"

          echo "üîç Detecting test failures with exit code: $exit_code, mode: $mode"

          # Primary check: exit code indicates failure
          if [[ "$exit_code" -ne 0 ]]; then
            echo "‚ùå Exit code $exit_code indicates test failure"

            if [[ -f "$output_file" ]]; then
              case "$mode" in
                "json")
                  # Enhanced JSON-based detection
                  detect_failures_from_json "$output_file" "$failures_file"
                  ;;
                "text"|*)
                  # Enhanced text-based detection
                  detect_failures_from_text "$output_file" "$failures_file"
                  ;;
              esac

              # Count detected failures
              if [[ -f "$failures_file" ]]; then
                DETECTED_FAILURES=$(wc -l < "$failures_file" 2>/dev/null || echo "0")
                echo "üìä Detected $DETECTED_FAILURES specific failures"
                return $DETECTED_FAILURES
              fi
            else
              echo "‚ö†Ô∏è Output file '$output_file' not found, relying on exit code"
              echo "Exit code indicates failure but no output file found" > "$failures_file"
              return 1
            fi
          else
            echo "‚úÖ Exit code 0 indicates success"
            touch "$failures_file"  # Create empty failures file
            return 0
          fi
        }

        # Smart and efficient JSON failure detection with unique signatures
        detect_failures_from_json() {
          local json_file="$1"
          local failures_file="$2"
          local signatures_file="${failures_file%.txt}-signatures.json"

          echo "üîç Using smart JSON-based failure detection on $json_file"

          # Quick JSON validation (< 0.1s) - check if file contains JSON test output
          if ! grep -q '^{.*"Action"' "$json_file" 2>/dev/null; then
            echo "‚ö†Ô∏è No JSON content detected, using text fallback"
            detect_failures_from_text "$json_file" "$failures_file"
            return
          fi

          echo "‚úÖ JSON content detected, processing efficiently..."

          # Initialize JSON array for structured failures with signatures
          echo '[]' > "$signatures_file"

          # Define common test validation filter to avoid duplication
          local test_failure_filter='select(.Action == "fail" and .Test != null and .Test != "" and .Test != "null" and (.Test | test("^Test[A-Za-z].*")))'

          # Fast single-pass JSON extraction for test failures (< 1s for 10K lines)
          # Filter JSON lines and parse in one pass - eliminates 2-minute hang
          # Note: Line numbers aren't available in Go test JSON output
          # IMPORTANT: Only detect actual test function failures, not package/suite completion events
          grep '^{' "$json_file" 2>/dev/null | \
            jq -r "$test_failure_filter"' |
              "--- FAIL: \(.Test) (\(.Package))"' \
            2>/dev/null > "$failures_file"

          # Create structured test failure entries with unique signatures
          if grep '^{' "$json_file" 2>/dev/null | jq -r "$test_failure_filter" 2>/dev/null | head -1 | grep -q .; then
            echo "üìù Creating structured test failure entries with enhanced output..."

            # First pass: Extract test failure basic info from Action == "fail" entries
            local temp_failures
            temp_failures=$(mktemp)
            grep '^{' "$json_file" 2>/dev/null | \
              jq -r "$test_failure_filter"' | {
                type: "test",
                package: .Package,
                test: (if (.Test and .Test != null and .Test != "null") then .Test else "unknown" end),
                signature: (.Package + ":" + (if (.Test and .Test != null and .Test != "null") then .Test else "unknown" end)),
                unique_id: (.Package + ":" + (if (.Test and .Test != null and .Test != "null") then .Test else "unknown" end) | gsub("[^a-zA-Z0-9_/.-]"; "_"))
              }' 2>/dev/null | jq -s '.' > "$temp_failures"

            # Second pass: Extract failure output from Action == "output" entries containing "--- FAIL:"
            local temp_outputs
            temp_outputs=$(mktemp)
            grep '^{' "$json_file" 2>/dev/null | \
              jq -r 'select(.Action == "output" and (.Output // "") | contains("--- FAIL:")) | {
                package: .Package,
                test: (if (.Test and .Test != null and .Test != "null") then .Test else "unknown" end),
                output: (.Output // ""),
                signature: (.Package + ":" + (if (.Test and .Test != null and .Test != "null") then .Test else "unknown" end))
              }' 2>/dev/null | jq -s '.' > "$temp_outputs"

            # Third pass: Merge failure info with outputs using signature as key
            jq -n --slurpfile failures "$temp_failures" --slurpfile outputs "$temp_outputs" '
              ($failures[0] // []) as $fail_list |
              ($outputs[0] // []) as $output_list |
              ($output_list | group_by(.signature) | map({key: .[0].signature, value: (map(.output) | join("\n"))})) as $output_map |
              $fail_list | map(. + {
                output: (($output_map | map(select(.key == .signature)) | .[0].value) // ""),
                line_number: null
              })' > "$signatures_file.tmp" 2>/dev/null && \
              mv "$signatures_file.tmp" "$signatures_file" || echo '[]' > "$signatures_file"

            # Cleanup temp files
            rm -f "$temp_failures" "$temp_outputs"
          fi

          # Also check for build failures which have FailedBuild field but no Test field
          local build_failures
          build_failures=$(grep '^{' "$json_file" 2>/dev/null | \
            jq -r 'select(.FailedBuild) | .Package // .ImportPath' 2>/dev/null | sort -u)

          if [[ -n "$build_failures" ]]; then
            echo "üî® Processing build failures with signatures..."

            # Create temporary array for build failures
            echo '[]' > "${signatures_file}.build"

            # Extract all build-output entries once before the loop for better performance
            local all_build_outputs
            all_build_outputs=$(grep '^{' "$json_file" 2>/dev/null | \
              jq -r 'select(.Action == "build-output" and .ImportPath) |
                     (.ImportPath | split(" ")[0]) + "\t" + .Output' 2>/dev/null)

            while IFS= read -r pkg; do
              if [[ -n "$pkg" ]]; then
                echo "--- BUILD FAILED: $pkg" >> "$failures_file"

                # Extract build error messages for this package from pre-extracted data
                local build_errors
                build_errors=$(echo "$all_build_outputs" | grep "^$pkg	" | cut -f2 | \
                  grep -E "^[^[:space:]]" | head -10)  # Limit to first 10 error lines

                local error_output=""
                if [[ -n "$build_errors" ]]; then
                  echo "$build_errors" | sed 's/^/    /' >> "$failures_file"
                  error_output="$build_errors"
                else
                  echo "    Build failed (no detailed error available)" >> "$failures_file"
                  error_output="Build failed (no detailed error available)"
                fi

                # Create structured build failure entry
                jq -n --arg pkg "$pkg" --arg errors "$error_output" '{
                  type: "build",
                  package: $pkg,
                  test: "build_compilation",
                  output: $errors,
                  signature: ($pkg + ":build_compilation"),
                  unique_id: ($pkg + ":build_compilation" | gsub("[^a-zA-Z0-9_/.-]"; "_"))
                }' >> "${signatures_file}.build" 2>/dev/null
              fi
            done <<< "$build_failures"

            # Merge build failures into main signatures file
            if [[ -s "${signatures_file}.build" ]]; then
              jq -s 'add' "$signatures_file" "${signatures_file}.build" > "${signatures_file}.tmp" 2>/dev/null && \
                mv "${signatures_file}.tmp" "$signatures_file" || echo '[]' > "$signatures_file"
            fi
            rm -f "${signatures_file}.build"
          fi

          local failure_count
          failure_count=$(wc -l < "$failures_file" 2>/dev/null | tr -d '\n\r' | xargs)
          [[ "$failure_count" =~ ^[0-9]+$ ]] || failure_count=0

          # Count distinct failures (test failures + build failures)
          local test_failure_count build_failure_count
          test_failure_count=$(grep -c "^--- FAIL:" "$failures_file" 2>/dev/null || echo "0")
          build_failure_count=$(grep -c "^--- BUILD FAILED:" "$failures_file" 2>/dev/null || echo "0")

          # Validate signatures file
          local unique_failure_count=0
          if [[ -s "$signatures_file" ]]; then
            unique_failure_count=$(jq 'length' "$signatures_file" 2>/dev/null || echo "0")
            echo "üìä Generated $unique_failure_count unique failure signatures"
          fi

          if [[ $test_failure_count -gt 0 ]] || [[ $build_failure_count -gt 0 ]]; then
            echo "‚úÖ Found $test_failure_count test failures and $build_failure_count build failures in JSON output"
            echo "üîç Created $unique_failure_count unique signatures for deduplication"
            return 0
          else
            echo "‚ÑπÔ∏è No failures detected in JSON output"
            return 0
          fi
        }

        # Enhanced text-based failure detection with signatures
        detect_failures_from_text() {
          local text_file="$1"
          local failures_file="$2"
          local detailed_failures_file="${failures_file%.txt}-detailed.txt"
          local signatures_file="${failures_file%.txt}-signatures.json"

          echo "üîç Using enhanced text-based failure detection on $text_file"

          # Initialize JSON array for structured failures with signatures
          echo '[]' > "$signatures_file"

          # Enhanced pattern matching for actual test failures only
          # Exclude standalone FAIL lines, package summaries, and exit status indicators
          local patterns=(
            '^---[[:space:]]*FAIL:[[:space:]]*[A-Za-z][A-Za-z0-9_]*'
            '^--[[:space:]]*FAIL:[[:space:]]*[A-Za-z][A-Za-z0-9_]*'
            '^\[?FAIL\]?[[:space:]]*[A-Za-z][A-Za-z0-9_]*'
          )

          local temp_failures=$(mktemp)
          local temp_detailed=$(mktemp)
          local found_any=false

          # First pass: Find all failure lines and capture context
          for pattern in "${patterns[@]}"; do
            if grep -E -A 15 "$pattern" "$text_file" >> "$temp_detailed" 2>/dev/null; then
              found_any=true
              # Also capture just the failure line for the summary
              grep -E "$pattern" "$text_file" >> "$temp_failures" 2>/dev/null || true
            fi
          done

          if [[ "$found_any" == "true" ]]; then
            # Process the detailed failures to create structured output
            echo "üîç Processing detailed failure output..."

            # Create a structured detailed failures file with error messages
            awk '
              BEGIN {
                current_test = ""
                capture_output = 0
                output_buffer = ""
              }
              /^(FAIL|---.*FAIL|--.*FAIL|\[?FAIL\]?)/ {
                # If we were capturing output, save it
                if (current_test != "" && output_buffer != "") {
                  print "TEST:" current_test
                  print "ERROR:" output_buffer
                  print "---SEPARATOR---"
                }

                # Start new test capture
                current_test = $0
                output_buffer = ""
                capture_output = 1
                next
              }
              capture_output == 1 && /^[[:space:]]*$/ {
                # Empty line might end the error context
                if (length(output_buffer) > 100) capture_output = 0
                next
              }
              capture_output == 1 && !/^(PASS|ok |FAIL|---.*FAIL|--.*FAIL)/ {
                # Capture error output lines
                if (output_buffer == "") {
                  output_buffer = $0
                } else {
                  output_buffer = output_buffer "\n" $0
                }
                # Stop if we have captured enough context
                if (length(output_buffer) > 1500) capture_output = 0
              }
              /^(PASS|ok )/ && capture_output == 1 {
                # Another test started, stop capturing
                capture_output = 0
              }
              END {
                # Save the last test if we were capturing
                if (current_test != "" && output_buffer != "") {
                  print "TEST:" current_test
                  print "ERROR:" output_buffer
                  print "---SEPARATOR---"
                }
              }
            ' "$temp_detailed" > "$detailed_failures_file" 2>/dev/null || true

            # Remove duplicates and sort for the summary file
            sort -u "$temp_failures" > "$failures_file"

            # Generate signatures from text failures
            echo "üìù Generating failure signatures from text output..."
            local temp_signatures=$(mktemp)
            echo '[]' > "$temp_signatures"

            while IFS= read -r failure_line; do
              # Skip empty lines and generic failures
              if [[ -n "$failure_line" && "$failure_line" != *"Generic test failure"* ]]; then
                # Skip standalone FAIL lines, package summaries, and exit status indicators
                if [[ "$failure_line" =~ ^(FAIL[[:space:]]*$|FAIL[[:space:]]+github\.com|exit[[:space:]]+status) ]]; then
                  continue
                fi

                # Extract package and test info from failure line
                # Pattern: --- FAIL: TestName (package.name)
                if [[ "$failure_line" =~ "FAIL:" ]]; then
                  local test_name=$(echo "$failure_line" | sed -E 's/^.*FAIL: ([^ ]+).*$/\1/' | head -c 200)
                  local package_name=$(echo "$failure_line" | sed -E 's/^.*\(([^):]+)[^)]*\).*$/\1/' | head -c 200)

                  # Handle build failures
                  if [[ "$failure_line" =~ "BUILD FAILED:" ]]; then
                    package_name=$(echo "$failure_line" | sed 's/^--- BUILD FAILED: //' | head -c 200)
                    test_name="build_compilation"

                    jq -n --arg pkg "$package_name" --arg test "$test_name" --arg output "$failure_line" '{
                      type: "build",
                      package: $pkg,
                      test: $test,
                      output: $output,
                      line_number: null,
                      signature: ($pkg + ":" + $test),
                      unique_id: (($pkg + ":" + $test) | gsub("[^a-zA-Z0-9_/.-]"; "_"))
                    }' >> "$temp_signatures.items"
                  else
                    # Handle fuzz test failures specifically
                    if [[ "$test_name" =~ ^Fuzz[A-Za-z0-9_]+ ]]; then
                      # For fuzz tests, create a more specific signature to avoid duplicates
                      # Only count the main fuzz test, not nested failures
                      if [[ ! "$failure_line" =~ "#[0-9]+" ]]; then
                        jq -n --arg pkg "$package_name" --arg test "$test_name" --arg output "$failure_line" '{
                          type: "fuzz_test",
                          package: $pkg,
                          test: $test,
                          output: $output,
                          line_number: null,
                          signature: ($pkg + ":" + $test + ":fuzz"),
                          unique_id: (($pkg + ":" + $test + ":fuzz") | gsub("[^a-zA-Z0-9_/.-]"; "_"))
                        }' >> "$temp_signatures.items"
                      fi
                    else
                      # Regular test failure
                      if [[ -n "$test_name" && -n "$package_name" && "$test_name" != "$package_name" ]]; then
                        jq -n --arg pkg "$package_name" --arg test "$test_name" --arg output "$failure_line" '{
                          type: "test",
                          package: $pkg,
                          test: $test,
                          output: $output,
                          line_number: null,
                          signature: ($pkg + ":" + $test),
                          unique_id: (($pkg + ":" + $test) | gsub("[^a-zA-Z0-9_/.-]"; "_"))
                        }' >> "$temp_signatures.items"
                      fi
                    fi
                  fi
                fi
              fi
            done < "$failures_file"

            # Combine signatures into array
            if [[ -f "$temp_signatures.items" ]]; then
              jq -s '.' "$temp_signatures.items" > "$signatures_file" 2>/dev/null || echo '[]' > "$signatures_file"
            fi
            rm -f "$temp_signatures" "$temp_signatures.items"

            local unique_signature_count=$(jq 'length' "$signatures_file" 2>/dev/null || echo "0")
            echo "‚úÖ Text parsing found $(wc -l < "$failures_file") failures with $unique_signature_count unique signatures"

            # Clean up
            rm -f "$temp_failures" "$temp_detailed"
            return 0
          fi

          # Fallback: look for any error indicators
          echo "‚ö†Ô∏è Standard failure patterns not found, checking for error indicators"
          local error_patterns=(
            'panic:'
            'fatal error:'
            'build failed'
            'compilation error'
            'timeout'
            'killed'
            'error:'
          )

          for pattern in "${error_patterns[@]}"; do
            if grep -i -A 5 "$pattern" "$text_file" >> "$temp_detailed" 2>/dev/null; then
              found_any=true
              grep -i "$pattern" "$text_file" >> "$temp_failures" 2>/dev/null || true
            fi
          done

          if [[ "$found_any" == "true" ]]; then
            sort -u "$temp_failures" > "$failures_file"
            cp "$temp_detailed" "$detailed_failures_file" 2>/dev/null || true
            echo "‚ö†Ô∏è Found $(wc -l < "$failures_file") error indicators (not standard test failures)"
            rm -f "$temp_failures" "$temp_detailed"
            return 0
          fi

          rm -f "$temp_failures" "$temp_detailed"

          # If exit code indicated failure but no patterns found, create generic entry
          if [[ "${TEST_EXIT_CODE:-0}" -ne 0 ]]; then
            echo "Generic test failure (exit code ${TEST_EXIT_CODE:-0}) - pattern detection failed" > "$failures_file"
            echo "‚ö†Ô∏è Exit code indicates failure but no recognizable patterns found"
            return 1
          else
            touch "$failures_file"  # Create empty failures file
            echo "‚úÖ No failures detected and exit code is 0"
            return 0
          fi
        }

        # Utility function for safe numeric validation
        sanitize_numeric() {
          local value="$1"
          value=$(echo "$value" | tr -d '\n\r' | xargs)
          if [[ "$value" =~ ^[0-9]+$ ]]; then
            echo "$value"
          else
            echo "0"
          fi
        }

        # Export functions for use in other steps
        export -f detect_test_failures
        export -f detect_failures_from_json
        export -f detect_failures_from_text
        export -f sanitize_numeric
        DETECTION_FUNCTIONS_EOF

        # Source the functions to make them available
        source test-failure-functions.sh
        echo "‚úÖ Failure detection functions defined and loaded"

    - name: üîç Detect test failures
      id: detect-failures
      shell: bash
      env:
        INPUT_OUTPUT_FILE: ${{ inputs.output-file }}
        INPUT_EXIT_CODE: ${{ inputs.exit-code }}
        INPUT_MODE: ${{ inputs.mode }}
        INPUT_FAILURES_FILE: ${{ inputs.failures-file }}
      run: |
        # Source the functions
        source test-failure-functions.sh

        # Run detection with provided inputs
        OUTPUT_FILE="$INPUT_OUTPUT_FILE"
        EXIT_CODE="$INPUT_EXIT_CODE"
        MODE="$INPUT_MODE"
        FAILURES_FILE="$INPUT_FAILURES_FILE"

        # Detect failures
        detect_test_failures "$OUTPUT_FILE" "$EXIT_CODE" "$MODE" "$FAILURES_FILE"
        detection_result=$?

        # Calculate outputs
        if [[ -f "$FAILURES_FILE" ]]; then
          FAILURE_COUNT=$(wc -l < "$FAILURES_FILE" 2>/dev/null | tr -d '\n\r' | xargs)
          FAILURE_COUNT=$(sanitize_numeric "$FAILURE_COUNT")
        else
          FAILURE_COUNT=0
        fi

        HAS_FAILURES="false"
        if [[ "$FAILURE_COUNT" -gt 0 ]] || [[ "$detection_result" -ne 0 ]]; then
          HAS_FAILURES="true"
        fi

        DETAILED_FILE="${FAILURES_FILE%.txt}-detailed.txt"

        # Set outputs
        echo "failure-count=$FAILURE_COUNT" >> $GITHUB_OUTPUT
        echo "has-failures=$HAS_FAILURES" >> $GITHUB_OUTPUT
        echo "detailed-failures-file=$DETAILED_FILE" >> $GITHUB_OUTPUT

        echo "üìä Failure detection results:"
        echo "   ‚Ä¢ Failure count: $FAILURE_COUNT"
        echo "   ‚Ä¢ Has failures: $HAS_FAILURES"
        echo "   ‚Ä¢ Detailed file: $DETAILED_FILE"

        # Always exit with 0 to not fail the workflow step
        # The outputs contain the failure information for downstream steps
        exit 0
