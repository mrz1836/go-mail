# ------------------------------------------------------------------------------------
#  Completion Report Statistics Processing (Reusable Workflow) (GoFortress)
#
#  Purpose: Process all statistics artifacts for the completion report including
#  cache statistics, benchmark results, coverage data, and lines of code summary.
#
#  This workflow handles:
#    - Cache statistics processing and hit rate analysis
#    - Benchmark results and performance metrics
#    - Code coverage reporting and badge generation
#    - Lines of code calculations and summary
#
#  Maintainer: @mrz1836
#
# ------------------------------------------------------------------------------------

name: GoFortress (Completion Statistics)

on:
  workflow_call:
    inputs:
      timing-metrics:
        description: "JSON string of timing data"
        required: true
        type: string
      env-json:
        description: "JSON string of environment variables"
        required: true
        type: string
    outputs:
      report-section:
        description: "Generated statistics markdown section"
        value: ${{ jobs.process-statistics.outputs.statistics-markdown }}
      cache-metrics:
        description: "Cache performance metrics"
        value: ${{ jobs.process-statistics.outputs.cache-data }}
      benchmark-metrics:
        description: "Benchmark performance metrics"
        value: ${{ jobs.process-statistics.outputs.benchmark-data }}
      coverage-metrics:
        description: "Coverage metrics"
        value: ${{ jobs.process-statistics.outputs.coverage-data }}

# Security: Restrict default permissions (jobs must explicitly request what they need)
permissions: {}

jobs:
  # ----------------------------------------------------------------------------------
  # Statistics Processing
  # ----------------------------------------------------------------------------------
  process-statistics:
    name: üìä Process Statistics
    runs-on: ubuntu-latest
    if: always()
    permissions:
      contents: read
      actions: read
    outputs:
      statistics-markdown: ${{ steps.set-output.outputs.content }}
      cache-data: ${{ steps.process-cache.outputs.cache-metrics }}
      benchmark-data: ${{ steps.process-benchmarks.outputs.benchmark-metrics }}
      coverage-data: ${{ steps.process-coverage.outputs.coverage-metrics }}
    steps:
      # --------------------------------------------------------------------
      # Checkout repository for local actions
      # --------------------------------------------------------------------
      - name: üì• Checkout Repository
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2

      # --------------------------------------------------------------------
      # Parse environment variables
      # --------------------------------------------------------------------
      - name: üîß Parse environment variables
        env:
          ENV_JSON: ${{ inputs.env-json }}
        run: |
          echo "üìã Setting environment variables..."
          echo "$ENV_JSON" | jq -r 'to_entries | .[] | "\(.key)=\(.value)"' | while IFS='=' read -r key value; do
            echo "$key=$value" >> $GITHUB_ENV
          done

      # --------------------------------------------------------------------
      # Detect if this is a release build (tag)
      # --------------------------------------------------------------------
      - name: üè∑Ô∏è Detect Release Build
        run: |
          # Detect if this is a release build
          IS_RELEASE_BUILD=false
          if [[ "$GITHUB_REF" == refs/tags/* ]]; then
            IS_RELEASE_BUILD=true
            TAG_NAME="${GITHUB_REF#refs/tags/}"
            echo "üì¶ Detected release build (tag: $TAG_NAME)"
            echo "IS_RELEASE_BUILD=true" >> $GITHUB_ENV
            echo "RELEASE_TAG=$TAG_NAME" >> $GITHUB_ENV
          else
            echo "üîÑ Regular build (non-release)"
            echo "IS_RELEASE_BUILD=false" >> $GITHUB_ENV
          fi

      # --------------------------------------------------------------------
      # Download specific artifacts needed for statistics processing
      # --------------------------------------------------------------------
      - name: üì• Download benchmark statistics
        if: always()
        uses: ./.github/actions/download-artifact-resilient
        with:
          pattern: "bench-stats-*"
          path: ./artifacts/
          merge-multiple: true
          max-retries: ${{ env.ARTIFACT_DOWNLOAD_RETRIES }}
          retry-delay: ${{ env.ARTIFACT_DOWNLOAD_RETRY_DELAY }}
          timeout: ${{ env.ARTIFACT_DOWNLOAD_TIMEOUT }}
          continue-on-error: ${{ env.ARTIFACT_DOWNLOAD_CONTINUE_ON_ERROR }}

      - name: üì• Download cache statistics
        if: always()
        uses: ./.github/actions/download-artifact-resilient
        with:
          pattern: "cache-stats-*"
          path: ./artifacts/
          merge-multiple: true
          max-retries: ${{ env.ARTIFACT_DOWNLOAD_RETRIES }}
          retry-delay: ${{ env.ARTIFACT_DOWNLOAD_RETRY_DELAY }}
          timeout: ${{ env.ARTIFACT_DOWNLOAD_TIMEOUT }}
          continue-on-error: ${{ env.ARTIFACT_DOWNLOAD_CONTINUE_ON_ERROR }}

      - name: üì• Download internal coverage statistics
        if: always() && env.ENABLE_GO_TESTS == 'true' && env.GO_COVERAGE_PROVIDER == 'internal'
        uses: ./.github/actions/download-artifact-resilient
        with:
          pattern: "coverage-stats-internal"
          path: ./artifacts/
          merge-multiple: false
          max-retries: ${{ env.ARTIFACT_DOWNLOAD_RETRIES }}
          retry-delay: ${{ env.ARTIFACT_DOWNLOAD_RETRY_DELAY }}
          timeout: ${{ env.ARTIFACT_DOWNLOAD_TIMEOUT }}
          continue-on-error: true

      - name: üì• Download codecov coverage statistics
        if: always() && env.ENABLE_GO_TESTS == 'true' && env.GO_COVERAGE_PROVIDER == 'codecov'
        uses: ./.github/actions/download-artifact-resilient
        with:
          pattern: "coverage-stats-codecov"
          path: ./artifacts/
          merge-multiple: false
          max-retries: ${{ env.ARTIFACT_DOWNLOAD_RETRIES }}
          retry-delay: ${{ env.ARTIFACT_DOWNLOAD_RETRY_DELAY }}
          timeout: ${{ env.ARTIFACT_DOWNLOAD_TIMEOUT }}
          continue-on-error: true

      - name: üóÇÔ∏è Flatten artifacts
        if: always()
        run: |
          echo "üóÇÔ∏è Flattening downloaded artifacts..."
          if [ -d "./artifacts/" ]; then
            find ./artifacts/ -name "*.json" -type f | while read -r file; do
              filename=$(basename "$file")
              echo "Moving $file to ./$filename"
              cp "$file" "./$filename"
            done
            echo "üìã Available stats files:"
            ls -la *-stats-*.json 2>/dev/null || echo "No stats files found"
          else
            echo "‚ö†Ô∏è No artifacts directory found"
          fi

      # --------------------------------------------------------------------
      # Setup MAGE-X for LOC metrics
      # --------------------------------------------------------------------
      - name: üîß Setup MAGE-X for LOC metrics
        uses: ./.github/actions/setup-magex
        with:
          magex-version: ${{ env.MAGE_X_VERSION }}
          runner-os: ${{ runner.os }}
          use-local: ${{ env.MAGE_X_USE_LOCAL }}

      # --------------------------------------------------------------------
      # Initialize statistics report section
      # --------------------------------------------------------------------
      - name: üìù Initialize Statistics Section
        run: |
          touch statistics-section.md

      # --------------------------------------------------------------------
      # Process cache statistics
      # --------------------------------------------------------------------
      - name: üíæ Process Cache Statistics
        id: process-cache
        run: |
          # Process cache statistics if available
          if compgen -G "cache-stats-*.json" >/dev/null 2>&1; then
            {
              echo ""
              echo "### üíæ Cache Statistics"
              echo "| Workflow/Job | OS | Go Version | Module Cache | Build Cache | Module Size | Build Size | Redis Cache | Redis Size |"
              echo "|--------------|----|-----------|--------------|-----------|-----------|------------|-------------|------------|"
            } >> statistics-section.md

            TOTAL_CACHE_HITS=0
            TOTAL_CACHE_ATTEMPTS=0
            WORKFLOWS_WITH_CACHE=""

            for stats_file in cache-stats-*.json; do
              if [ -f "$stats_file" ]; then
                OS=$(jq -r '.os' "$stats_file")
                GO_VER=$(jq -r '.go_version' "$stats_file")
                WORKFLOW=$(jq -r '.workflow // "unknown"' "$stats_file")
                JOB_NAME=$(jq -r '.job_name // ""' "$stats_file")
                GOMOD_HIT=$(jq -r '.gomod_cache_hit' "$stats_file")
                GOBUILD_HIT=$(jq -r '.gobuild_cache_hit' "$stats_file")
                GOMOD_SIZE=$(jq -r '.cache_size_gomod' "$stats_file")
                GOBUILD_SIZE=$(jq -r '.cache_size_gobuild' "$stats_file")

                # Redis cache statistics
                REDIS_ENABLED=$(jq -r '.redis_enabled // "false"' "$stats_file")
                REDIS_HIT=$(jq -r '.redis_cache_hit // "false"' "$stats_file")
                REDIS_SIZE=$(jq -r '.redis_image_size_mb // "0"' "$stats_file")

                GOMOD_ICON=$([[ "$GOMOD_HIT" == "true" ]] && echo "‚úÖ Hit" || echo "‚ùå Miss")
                GOBUILD_ICON=$([[ "$GOBUILD_HIT" == "true" ]] && echo "‚úÖ Hit" || echo "‚ùå Miss")

                # Redis cache display
                if [[ "$REDIS_ENABLED" == "true" ]]; then
                  REDIS_ICON=$([[ "$REDIS_HIT" == "true" ]] && echo "‚úÖ Hit" || echo "‚ùå Miss")
                  REDIS_SIZE_DISPLAY="${REDIS_SIZE}MB"
                else
                  REDIS_ICON="‚ûñ N/A"
                  REDIS_SIZE_DISPLAY="‚ûñ"
                fi

                # Create workflow/job identifier
                if [[ -n "$JOB_NAME" && "$JOB_NAME" != "null" ]]; then
                  WORKFLOW_JOB="${WORKFLOW}/${JOB_NAME}"
                else
                  WORKFLOW_JOB="${WORKFLOW}"
                fi

                echo "| $WORKFLOW_JOB | $OS | $GO_VER | $GOMOD_ICON | $GOBUILD_ICON | $GOMOD_SIZE | $GOBUILD_SIZE | $REDIS_ICON | $REDIS_SIZE_DISPLAY |" >> statistics-section.md

                [[ "$GOMOD_HIT" == "true" ]] && TOTAL_CACHE_HITS=$((TOTAL_CACHE_HITS + 1))
                [[ "$GOBUILD_HIT" == "true" ]] && TOTAL_CACHE_HITS=$((TOTAL_CACHE_HITS + 1))
                [[ "$REDIS_ENABLED" == "true" && "$REDIS_HIT" == "true" ]] && TOTAL_CACHE_HITS=$((TOTAL_CACHE_HITS + 1))

                TOTAL_CACHE_ATTEMPTS=$((TOTAL_CACHE_ATTEMPTS + 2))
                [[ "$REDIS_ENABLED" == "true" ]] && TOTAL_CACHE_ATTEMPTS=$((TOTAL_CACHE_ATTEMPTS + 1))

                # Track workflows that used cache
                if [[ "$WORKFLOWS_WITH_CACHE" != *"$WORKFLOW"* ]]; then
                  if [[ -z "$WORKFLOWS_WITH_CACHE" ]]; then
                    WORKFLOWS_WITH_CACHE="$WORKFLOW"
                  else
                    WORKFLOWS_WITH_CACHE="${WORKFLOWS_WITH_CACHE}, $WORKFLOW"
                  fi
                fi
              fi
            done

            # Add cache efficiency summary
            if [[ $TOTAL_CACHE_ATTEMPTS -gt 0 ]]; then
              CACHE_HIT_RATE=$((TOTAL_CACHE_HITS * 100 / TOTAL_CACHE_ATTEMPTS))
              {
                echo ""
                echo "**Cache Performance Summary:**"
                echo "- **Overall Hit Rate**: ${CACHE_HIT_RATE}% (${TOTAL_CACHE_HITS}/${TOTAL_CACHE_ATTEMPTS} cache operations)"
                echo "- **Workflows Using Cache**: $WORKFLOWS_WITH_CACHE"
              } >> statistics-section.md

              if [[ $CACHE_HIT_RATE -ge 80 ]]; then
                echo "- **Cache Efficiency**: üöÄ Excellent (${CACHE_HIT_RATE}% hit rate)" >> statistics-section.md
              elif [[ $CACHE_HIT_RATE -ge 60 ]]; then
                echo "- **Cache Efficiency**: ‚úÖ Good (${CACHE_HIT_RATE}% hit rate)" >> statistics-section.md
              elif [[ $CACHE_HIT_RATE -ge 40 ]]; then
                echo "- **Cache Efficiency**: ‚ö†Ô∏è Fair (${CACHE_HIT_RATE}% hit rate)" >> statistics-section.md
              else
                echo "- **Cache Efficiency**: ‚ùå Poor (${CACHE_HIT_RATE}% hit rate - consider optimizing cache strategy)" >> statistics-section.md
              fi

              # Store metrics for output
              echo "cache-metrics={\"hit_rate\":$CACHE_HIT_RATE,\"total_hits\":$TOTAL_CACHE_HITS,\"total_attempts\":$TOTAL_CACHE_ATTEMPTS}" >> $GITHUB_OUTPUT
            fi

            # Add spacing after cache section
            echo "" >> statistics-section.md
            echo "<br><br>" >> statistics-section.md
          else
            # No cache statistics available
            {
              echo ""
              echo "### üíæ Cache Statistics"
              echo ""
              echo "| Status | Details |"
              echo "|--------|---------|"
              echo "| **Cache Data** | ‚ö†Ô∏è No cache statistics available |"
              echo "| **Reason** | Cache stats may not be available for this workflow run |"
              echo ""
              echo "<br><br>"
            } >> statistics-section.md
          fi

      # --------------------------------------------------------------------
      # Process benchmark statistics
      # --------------------------------------------------------------------
      - name: üèÉ Process Benchmark Statistics
        id: process-benchmarks
        run: |
          # Process benchmark statistics if available
          if compgen -G "bench-stats-*.json" >/dev/null 2>&1; then
            {
              echo ""
              echo ""
              echo "### ‚ö° Benchmark Results"
            } >> statistics-section.md

            # Get benchmark mode from the first stats file
            BENCH_MODE="normal"
            for stats_file in bench-stats-*.json; do
              if [ -f "$stats_file" ]; then
                BENCH_MODE=$(jq -r '.benchmark_mode // "normal"' "$stats_file")
                break
              fi
            done

            {
              echo ""
              echo "**Mode**: \`$BENCH_MODE\` $(case "$BENCH_MODE" in quick) echo "(Quick 50ms runs)" ;; full) echo "(Comprehensive 10s runs)" ;; *) echo "(Normal 100ms runs)" ;; esac)"
              echo ""
              echo "| Benchmark Suite | Duration | Benchmarks | Status |"
              echo "|-----------------|----------|------------|--------|"
            } >> statistics-section.md

            TOTAL_BENCHMARKS=0
            TOTAL_DURATION=0

            for stats_file in bench-stats-*.json; do
              if [ -f "$stats_file" ]; then
                NAME=$(jq -r '.name' "$stats_file")
                DURATION=$(jq -r '.duration_seconds' "$stats_file")
                BENCHMARK_COUNT=$(jq -r '.benchmark_count' "$stats_file")
                STATUS=$(jq -r '.status' "$stats_file")

                DURATION_MIN=$((DURATION / 60))
                DURATION_SEC=$((DURATION % 60))
                STATUS_ICON=$([[ "$STATUS" == "success" ]] && echo "‚úÖ" || echo "‚ùå")

                echo "| $NAME | ${DURATION_MIN}m ${DURATION_SEC}s | $BENCHMARK_COUNT | $STATUS_ICON |" >> statistics-section.md

                TOTAL_BENCHMARKS=$((TOTAL_BENCHMARKS + BENCHMARK_COUNT))
                TOTAL_DURATION=$((TOTAL_DURATION + DURATION))
              fi
            done

            # Display detailed benchmark results
            {
              echo ""
              echo "<details>"
              echo "<summary>Detailed Benchmark Results</summary>"
              echo ""
            } >> statistics-section.md

            for stats_file in bench-stats-*.json; do
              if [ -f "$stats_file" ]; then
                NAME=$(jq -r '.name' "$stats_file")
                BENCHMARK_SUMMARY=$(jq -r '.benchmark_summary' "$stats_file")
                if [ -n "$BENCHMARK_SUMMARY" ] && [ "$BENCHMARK_SUMMARY" != "null" ]; then
                  {
                    echo "#### $NAME"
                    echo "$BENCHMARK_SUMMARY"
                    echo ""
                  } >> statistics-section.md
                fi
              fi
            done

            echo "</details><br><br>" >> statistics-section.md

            # Store metrics for output
            echo "benchmark-metrics={\"total_benchmarks\":$TOTAL_BENCHMARKS,\"total_duration\":$TOTAL_DURATION,\"mode\":\"$BENCH_MODE\"}" >> $GITHUB_OUTPUT
          else
            # No benchmark statistics available
            {
              echo ""
              echo ""
              echo "### ‚ö° Benchmark Results"
              echo ""
              echo "| Status | Details |"
              echo "|--------|---------|"
              echo "| **Benchmarks** | ‚ö†Ô∏è No benchmark data available |"
              echo "| **Reason** | Benchmarks may have been skipped or data not uploaded |"
              echo ""
              echo "<br><br>"
            } >> statistics-section.md
          fi

      # --------------------------------------------------------------------
      # Process coverage statistics
      # --------------------------------------------------------------------
      - name: üìä Process Coverage Statistics
        id: process-coverage
        run: |
          # Process coverage statistics if available
          echo "üîç Looking for coverage statistics files..."

          # Check for both coverage-stats-*.json and coverage-stats-internal-*.json patterns
          COVERAGE_FILES_FOUND=false
          if compgen -G "coverage-stats-*.json" >/dev/null 2>&1; then
            echo "üìã Found coverage-stats-*.json files:"
            ls -la coverage-stats-*.json || echo "None"
            COVERAGE_FILES_FOUND=true
          fi

          if compgen -G "coverage-stats-internal-*.json" >/dev/null 2>&1; then
            echo "üìã Found coverage-stats-internal-*.json files:"
            ls -la coverage-stats-internal-*.json || echo "None"
            COVERAGE_FILES_FOUND=true
          fi

          if [[ "$COVERAGE_FILES_FOUND" == "true" ]]; then
            # Check if we have valid coverage data before creating section
            HAS_COVERAGE_DATA=false
            VALID_COVERAGE_FILE=""

            # Check both patterns for valid coverage data, prioritizing updated files
            UPDATED_FILE_FOUND=false
            for pattern in "coverage-stats-*.json" "coverage-stats-internal-*.json"; do
              if compgen -G "$pattern" >/dev/null 2>&1; then
                # First, prioritize any "updated" statistics files
                for stats_file in $pattern; do
                  if [ -f "$stats_file" ] && [[ "$stats_file" == *"updated"* ]]; then
                    echo "üîç Checking UPDATED statistics file: $stats_file"
                    COVERAGE_PERCENT=$(jq -r '.coverage_percent // .coverage_percentage // "null"' "$stats_file")
                    echo "  - Coverage value found: '$COVERAGE_PERCENT'"

                    if [[ "$COVERAGE_PERCENT" != "null" ]] && [[ "$COVERAGE_PERCENT" != "N/A" ]] && [[ -n "$COVERAGE_PERCENT" ]]; then
                      echo "‚úÖ Valid coverage data found in UPDATED file: $stats_file"
                      HAS_COVERAGE_DATA=true
                      VALID_COVERAGE_FILE="$stats_file"
                      UPDATED_FILE_FOUND=true
                      break 2
                    fi
                  fi
                done

                # If no updated file found, check regular files
                if [[ "$UPDATED_FILE_FOUND" == "false" ]]; then
                  for stats_file in $pattern; do
                    if [ -f "$stats_file" ] && [[ "$stats_file" != *"updated"* ]]; then
                      echo "üîç Checking $stats_file for valid coverage data..."
                      # Try both field names: coverage_percent and coverage_percentage
                      COVERAGE_PERCENT=$(jq -r '.coverage_percent // .coverage_percentage // "null"' "$stats_file")
                      echo "  - Coverage value found: '$COVERAGE_PERCENT'"

                      if [[ "$COVERAGE_PERCENT" != "null" ]] && [[ "$COVERAGE_PERCENT" != "N/A" ]] && [[ -n "$COVERAGE_PERCENT" ]]; then
                        echo "‚úÖ Valid coverage data found in $stats_file"
                        HAS_COVERAGE_DATA=true
                        VALID_COVERAGE_FILE="$stats_file"
                        break 2  # Break out of both loops
                      else
                        echo "‚ö†Ô∏è No valid coverage data in $stats_file"
                      fi
                    fi
                  done
                fi
              fi
            done

            if [[ "$HAS_COVERAGE_DATA" == "true" ]] && [[ -n "$VALID_COVERAGE_FILE" ]]; then
              {
                echo ""
                echo "<br><br>"
                echo ""
                echo "### üìà Code Coverage Report"
              } >> statistics-section.md

              # Process the valid coverage file
              echo "üìä Processing coverage data from: $VALID_COVERAGE_FILE"

              # Extract coverage percentage (try both field names)
              COVERAGE_PERCENT=$(jq -r '.coverage_percent // .coverage_percentage // "N/A"' "$VALID_COVERAGE_FILE")
              PROCESSING_TIME=$(jq -r '.processing_time_seconds // "N/A"' "$VALID_COVERAGE_FILE")
              FILES_PROCESSED=$(jq -r '.files_processed // "N/A"' "$VALID_COVERAGE_FILE")
              BADGE_GENERATED=$(jq -r '.badge_generated // "false"' "$VALID_COVERAGE_FILE")
              PAGES_DEPLOYED=$(jq -r '.pages_deployed // "false"' "$VALID_COVERAGE_FILE")
              COVERAGE_PROVIDER=$(jq -r '.provider // "N/A"' "$VALID_COVERAGE_FILE")

              echo "üìã Coverage metrics: ${COVERAGE_PERCENT}%, ${FILES_PROCESSED} files, ${PROCESSING_TIME}s processing"

              {
                echo "| Metric | Value |"
                echo "|--------|-------|"
                echo "| **Coverage Percentage** | $COVERAGE_PERCENT% |"
                echo "| **Processing Time** | ${PROCESSING_TIME}s |"
                echo "| **Files Processed** | $FILES_PROCESSED |"
                echo "| **Coverage Provider** | $([ "$COVERAGE_PROVIDER" == "internal" ] && echo "go-coverage" || ([ "$COVERAGE_PROVIDER" == "codecov" ] && echo "Codecov" || echo "$COVERAGE_PROVIDER")) |"
                echo "| **Badge Generated** | $([ "$BADGE_GENERATED" == "true" ] && echo "‚úÖ Yes" || echo "‚ùå No") |"
                echo "| **Pages Deployed** | $([ "$PAGES_DEPLOYED" == "true" ] && echo "‚úÖ Yes" || echo "‚ùå No") |"
              } >> statistics-section.md

              # Store metrics for output
              echo "coverage-metrics={\"percentage\":\"$COVERAGE_PERCENT\",\"files_processed\":\"$FILES_PROCESSED\",\"processing_time\":\"$PROCESSING_TIME\",\"provider\":\"$COVERAGE_PROVIDER\"}" >> $GITHUB_OUTPUT
            fi
          elif [[ "${{ env.ENABLE_CODE_COVERAGE }}" == "true" ]]; then
            # Coverage is enabled but no coverage data found - show status
            {
              echo ""
              echo "<br><br>"
              echo ""
              echo "### üìà Code Coverage Status"
              echo "| Status | Details |"
              echo "|--------|---------|"

              # Show different message for release builds vs regular builds
              if [[ "${IS_RELEASE_BUILD:-false}" == "true" ]]; then
                echo "| **Coverage** | üì¶ Coverage analysis skipped for release builds |"
                echo "| **Reason** | Coverage processing is disabled during releases to optimize build time |"
                if [[ -n "${RELEASE_TAG:-}" ]]; then
                  echo "| **Release Tag** | \`${RELEASE_TAG}\` |"
                fi
              else
                echo "| **Coverage** | ‚ö†Ô∏è No coverage data available - check job logs |"
              fi

              echo "| **Threshold** | ${{ env.GO_COVERAGE_THRESHOLD }}% minimum |"
              echo "| **Badge Style** | ${{ env.GO_COVERAGE_BADGE_STYLE }} |"
              echo "| **PR Comments** | $([ "${{ env.GO_COVERAGE_POST_COMMENTS }}" == "true" ] && echo "‚úÖ Enabled" || echo "‚ùå Disabled") |"
              echo "| **Theme** | ${{ env.GO_COVERAGE_REPORT_THEME }} |"
            } >> statistics-section.md
          fi

      # --------------------------------------------------------------------
      # Generate Lines of Code Summary
      # --------------------------------------------------------------------
      - name: üìä Generate Lines of Code Summary
        id: process-loc
        run: |
          echo "üìä Running magex metrics:loc json..."

          # Run magex metrics:loc json and capture output
          LOC_OUTPUT=$(magex metrics:loc json 2>&1 || true)
          LOC_FOUND=false

          if [[ -n "$LOC_OUTPUT" ]]; then
            echo "üìã magex metrics:loc json output:"
            echo "$LOC_OUTPUT"

            # Parse JSON output using jq
            TEST_FILES_LOC=$(echo "$LOC_OUTPUT" | jq -r '.test_files_loc // empty')
            TEST_FILES_COUNT=$(echo "$LOC_OUTPUT" | jq -r '.test_files_count // empty')
            GO_FILES_LOC=$(echo "$LOC_OUTPUT" | jq -r '.go_files_loc // empty')
            GO_FILES_COUNT=$(echo "$LOC_OUTPUT" | jq -r '.go_files_count // empty')
            TOTAL_LOC=$(echo "$LOC_OUTPUT" | jq -r '.total_loc // empty')
            TOTAL_FILES_COUNT=$(echo "$LOC_OUTPUT" | jq -r '.total_files_count // empty')
            LOC_DATE=$(echo "$LOC_OUTPUT" | jq -r '.date // empty')

            # Parse new size metrics
            TEST_FILES_SIZE=$(echo "$LOC_OUTPUT" | jq -r '.test_files_size_human // empty')
            GO_FILES_SIZE=$(echo "$LOC_OUTPUT" | jq -r '.go_files_size_human // empty')
            TOTAL_SIZE=$(echo "$LOC_OUTPUT" | jq -r '.total_size_human // empty')
            TEST_AVG_SIZE_BYTES=$(echo "$LOC_OUTPUT" | jq -r '.test_avg_size_bytes // empty')
            GO_AVG_SIZE_BYTES=$(echo "$LOC_OUTPUT" | jq -r '.go_avg_size_bytes // empty')

            # Parse code quality metrics
            AVG_LINES_PER_FILE=$(echo "$LOC_OUTPUT" | jq -r '.avg_lines_per_file // empty')
            TEST_COVERAGE_RATIO=$(echo "$LOC_OUTPUT" | jq -r '.test_coverage_ratio // empty')
            PACKAGE_COUNT=$(echo "$LOC_OUTPUT" | jq -r '.package_count // empty')

            echo "  - Test Files LOC: '$TEST_FILES_LOC' (count: $TEST_FILES_COUNT)"
            echo "  - Go Files LOC: '$GO_FILES_LOC' (count: $GO_FILES_COUNT)"
            echo "  - Total LOC: '$TOTAL_LOC' (files: $TOTAL_FILES_COUNT)"
            echo "  - Date: '$LOC_DATE'"

            # Check if we have valid LOC data
            if [[ -n "$TEST_FILES_LOC" ]] && [[ -n "$GO_FILES_LOC" ]] && [[ -n "$TOTAL_LOC" ]]; then
              LOC_FOUND=true
              echo "‚úÖ Successfully parsed LOC JSON data"

              # Optionally warn if new metrics are missing
              if [[ -z "$TOTAL_SIZE" ]] || [[ -z "$AVG_LINES_PER_FILE" ]]; then
                echo "‚ö†Ô∏è Some enhanced metrics are missing (older magex version?)"
              fi
            fi
          else
            echo "‚ö†Ô∏è No output from magex metrics:loc json"
          fi

          # Display LOC section
          if [[ "$LOC_FOUND" == "true" ]]; then
            # Format numbers with commas for display
            DISPLAY_TEST_LOC=$(LC_NUMERIC=en_US.UTF-8 printf "%'d" "${TEST_FILES_LOC:-0}")
            DISPLAY_TEST_COUNT="${TEST_FILES_COUNT:-N/A}"
            DISPLAY_GO_LOC=$(LC_NUMERIC=en_US.UTF-8 printf "%'d" "${GO_FILES_LOC:-0}")
            DISPLAY_GO_COUNT="${GO_FILES_COUNT:-N/A}"
            DISPLAY_TOTAL_LOC=$(LC_NUMERIC=en_US.UTF-8 printf "%'d" "${TOTAL_LOC:-0}")
            DISPLAY_TOTAL_FILES="${TOTAL_FILES_COUNT:-N/A}"
            DISPLAY_LOC_DATE="${LOC_DATE:-N/A}"

            # Format average sizes for display
            if [[ -n "$TEST_AVG_SIZE_BYTES" ]] && [[ "$TEST_AVG_SIZE_BYTES" != "0" ]]; then
              DISPLAY_TEST_AVG_SIZE=$(numfmt --to=iec-i --suffix=B "$TEST_AVG_SIZE_BYTES" 2>/dev/null || echo "${TEST_AVG_SIZE_BYTES}B")
            else
              DISPLAY_TEST_AVG_SIZE="N/A"
            fi

            if [[ -n "$GO_AVG_SIZE_BYTES" ]] && [[ "$GO_AVG_SIZE_BYTES" != "0" ]]; then
              DISPLAY_GO_AVG_SIZE=$(numfmt --to=iec-i --suffix=B "$GO_AVG_SIZE_BYTES" 2>/dev/null || echo "${GO_AVG_SIZE_BYTES}B")
            else
              DISPLAY_GO_AVG_SIZE="N/A"
            fi

            DISPLAY_TEST_SIZE="${TEST_FILES_SIZE:-N/A}"
            DISPLAY_GO_SIZE="${GO_FILES_SIZE:-N/A}"
            DISPLAY_TOTAL_SIZE="${TOTAL_SIZE:-N/A}"

            {
              echo ""
              echo "<br><br>"
              echo ""
              echo "### üìä Lines of Code Summary"
              echo "| Type | Lines of Code | Files | Total Size | Avg Size | Date |"
              echo "|------|---------------|-------|------------|----------|------|"
              echo "| Test Files | $DISPLAY_TEST_LOC | $DISPLAY_TEST_COUNT | $DISPLAY_TEST_SIZE | $DISPLAY_TEST_AVG_SIZE | $DISPLAY_LOC_DATE |"
              echo "| Go Files | $DISPLAY_GO_LOC | $DISPLAY_GO_COUNT | $DISPLAY_GO_SIZE | $DISPLAY_GO_AVG_SIZE | $DISPLAY_LOC_DATE |"
              echo "| **Total** | **$DISPLAY_TOTAL_LOC** | **$DISPLAY_TOTAL_FILES** | **$DISPLAY_TOTAL_SIZE** | | |"
              echo ""

              # Display code quality metrics if available
              if [[ -n "$AVG_LINES_PER_FILE" ]] || [[ -n "$TEST_COVERAGE_RATIO" ]] || [[ -n "$PACKAGE_COUNT" ]]; then
                echo "#### üìà Code Quality Metrics"
                echo ""
                echo "| Metric | Value |"
                echo "|--------|-------|"

                # Display average lines per file
                if [[ -n "$AVG_LINES_PER_FILE" ]]; then
                  DISPLAY_AVG_LINES=$(LC_NUMERIC=en_US.UTF-8 printf "%.1f" "${AVG_LINES_PER_FILE}")
                  echo "| Average Lines per File | $DISPLAY_AVG_LINES |"
                fi

                # Display test coverage ratio
                if [[ -n "$TEST_COVERAGE_RATIO" ]]; then
                  DISPLAY_COVERAGE=$(LC_NUMERIC=en_US.UTF-8 printf "%.1f%%" "${TEST_COVERAGE_RATIO}")
                  echo "| Test Coverage Ratio | $DISPLAY_COVERAGE |"
                fi

                # Display package count
                if [[ -n "$PACKAGE_COUNT" ]]; then
                  echo "| Package/Directory Count | $PACKAGE_COUNT |"
                fi

                # Display total size
                if [[ -n "$TOTAL_SIZE" ]]; then
                  echo "| Total Project Size | $TOTAL_SIZE |"
                fi

                echo ""
              fi

              echo "<br><br>"
            } >> statistics-section.md

            echo "‚úÖ LOC section added: Test=$DISPLAY_TEST_LOC ($DISPLAY_TEST_COUNT files), Go=$DISPLAY_GO_LOC ($DISPLAY_GO_COUNT files), Total=$DISPLAY_TOTAL_LOC ($DISPLAY_TOTAL_FILES files)"
          else
            echo "‚ö†Ô∏è Could not collect LOC data"
            {
              echo ""
              echo "<br><br>"
              echo ""
              echo "### üìä Lines of Code Summary"
              echo "| Status | Details |"
              echo "|--------|---------|"
              echo "| **Lines of Code** | ‚ùå Data not available |"
              echo "| **Reason** | magex metrics:loc json command failed or produced unexpected output |"
              echo ""
              echo "<br><br>"
            } >> statistics-section.md
          fi

      # --------------------------------------------------------------------
      # Upload statistics section
      # --------------------------------------------------------------------
      - name: üì§ Upload Statistics Section
        id: upload-section
        if: always()
        run: |
          if [ -f "statistics-section.md" ] && [ -s "statistics-section.md" ]; then
            echo "üìä Statistics section found, uploading..."
            ls -la statistics-section.md
            echo "üìã Content preview:"
            head -5 statistics-section.md
          else
            echo "‚ö†Ô∏è Statistics section file missing or empty, creating minimal section..."
            echo "### üìä Statistics Section" > statistics-section.md
            echo "No statistics data available for this run." >> statistics-section.md
          fi

      - name: üì§ Upload Statistics Artifact
        uses: ./.github/actions/upload-statistics
        with:
          artifact-name: "statistics-section"
          artifact-path: "statistics-section.md"
          retention-days: "1"
          if-no-files-found: "warn"

      - name: üìã Set Output Content
        id: set-output
        run: |
          echo "content<<EOF" >> $GITHUB_OUTPUT
          cat statistics-section.md >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
