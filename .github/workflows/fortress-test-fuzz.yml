# ------------------------------------------------------------------------------------
#  Fuzz Testing (Reusable Workflow) (GoFortress)
#
#  Purpose: Execute Go fuzz tests to detect edge cases and potential security
#  vulnerabilities through automated input generation and testing.
#
#  This workflow handles:
#    - Fuzz test execution on primary runner with primary Go version
#    - Panic and error detection from fuzz test output
#    - Failure analysis and structured reporting
#    - Statistics collection and artifact uploading
#    - Cache performance tracking
#
#  Maintainer: @mrz1836
#
# ------------------------------------------------------------------------------------

name: GoFortress (Fuzz Tests)

on:
  workflow_call:
    inputs:
      env-json:
        description: "JSON string of environment variables"
        required: true
        type: string
      primary-runner:
        description: "Primary runner OS"
        required: true
        type: string
      go-primary-version:
        description: "Primary Go version"
        required: true
        type: string
      go-secondary-version:
        description: "Secondary Go version"
        required: true
        type: string
      fuzz-testing-enabled:
        description: "Whether fuzz testing is enabled"
        required: true
        type: string
      go-sum-file:
        description: "Path to go.sum file for dependency verification"
        required: true
        type: string

# Security: Restrictive default permissions with job-level overrides for least privilege access
permissions:
  contents: read

jobs:
  # ----------------------------------------------------------------------------------
  # Fuzz Testing
  # ----------------------------------------------------------------------------------
  fuzz-tests:
    name: ðŸ§ª Fuzz Tests
    if: inputs.fuzz-testing-enabled == 'true'
    timeout-minutes: 15 # Fuzz tests have shorter timeout
    permissions:
      contents: read # Read repository content for testing
    runs-on: ${{ inputs.primary-runner }}

    steps:
      # --------------------------------------------------------------------
      # Checkout code (required for local actions)
      # --------------------------------------------------------------------
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@1af3b93b6815bc44a9784bd300feb67ff0d1eeb3 # v6.0.0

      # --------------------------------------------------------------------
      # Parse environment variables
      # --------------------------------------------------------------------
      - name: ðŸ”§ Parse environment variables
        uses: ./.github/actions/parse-env
        with:
          env-json: ${{ inputs.env-json }}

      # --------------------------------------------------------------------
      # Setup Go with caching and version management (primary version only)
      # --------------------------------------------------------------------
      - name: ðŸ—ï¸ Setup Go with Cache
        id: setup-go-fuzz
        uses: ./.github/actions/setup-go-with-cache
        with:
          go-version: ${{ inputs.go-primary-version }}
          matrix-os: ${{ inputs.primary-runner }}
          go-primary-version: ${{ inputs.go-primary-version }}
          go-secondary-version: ${{ inputs.go-secondary-version }}
          go-sum-file: ${{ inputs.go-sum-file }}
          enable-multi-module: ${{ env.ENABLE_MULTI_MODULE_TESTING }}

      # --------------------------------------------------------------------
      # Extract Go module directory from GO_SUM_FILE path
      # --------------------------------------------------------------------
      - name: ðŸ”§ Extract Go module directory
        uses: ./.github/actions/extract-module-dir
        with:
          go-sum-file: ${{ inputs.go-sum-file }}

      # --------------------------------------------------------------------
      # Setup MAGE-X (required for magex test commands)
      # --------------------------------------------------------------------
      - name: ðŸ”§ Setup MAGE-X
        uses: ./.github/actions/setup-magex
        with:
          magex-version: ${{ env.MAGE_X_VERSION }}
          runner-os: ${{ inputs.primary-runner }}
          use-local: ${{ env.MAGE_X_USE_LOCAL }}

      # --------------------------------------------------------------------
      # Start fuzz test timer
      # --------------------------------------------------------------------
      - name: â±ï¸ Start fuzz test timer
        id: fuzz-timer
        run: |
          echo "fuzz-start=$(date +%s)" >> $GITHUB_OUTPUT
          echo "ðŸ•’ Fuzz test timer started at: $(date -u +%Y-%m-%dT%H:%M:%SZ)"

      # --------------------------------------------------------------------
      # Setup fuzz test failure detection functions
      # --------------------------------------------------------------------
      - name: ðŸ”§ Setup failure detection for fuzz tests
        uses: ./.github/actions/test-failure-detection
        with:
          output-file: "fuzz-output.log"
          mode: "text"

      # --------------------------------------------------------------------
      # Run fuzz tests
      # --------------------------------------------------------------------
      - name: ðŸ§ª Run fuzz tests
        id: run-fuzz-tests
        continue-on-error: true
        run: |
          echo "ðŸ§ª Running fuzz tests in parallel..."
          FUZZ_TIMEOUT="${TEST_TIMEOUT_FUZZ:-5m}"
          GO_MODULE_DIR="${{ env.GO_MODULE_DIR }}"

          if [ -n "$GO_MODULE_DIR" ]; then
            echo "ðŸ”§ Running magex test:fuzz from directory: $GO_MODULE_DIR"
            (cd "$GO_MODULE_DIR" && magex test:fuzz time=5s -timeout $FUZZ_TIMEOUT) 2>&1 | tee fuzz-output.log
          else
            echo "ðŸ”§ Running magex test:fuzz from repository root"
            magex test:fuzz time=5s -timeout $FUZZ_TIMEOUT 2>&1 | tee fuzz-output.log
          fi

          FUZZ_EXIT_CODE=${PIPESTATUS[0]}
          echo "ðŸ”§ Fuzz tests completed with timeout: $FUZZ_TIMEOUT"

          # Store the exit code for later steps
          echo "FUZZ_EXIT_CODE=$FUZZ_EXIT_CODE" >> $GITHUB_ENV
          echo "fuzz-exit-code=$FUZZ_EXIT_CODE" >> $GITHUB_OUTPUT

          if [[ $FUZZ_EXIT_CODE -eq 0 ]]; then
            echo "âœ… Fuzz tests completed successfully"
          else
            echo "âŒ Fuzz tests failed with exit code $FUZZ_EXIT_CODE"
          fi

      # --------------------------------------------------------------------
      # Analyze fuzz test failures using detection functions
      # --------------------------------------------------------------------
      - name: ðŸ” Analyze fuzz test failures
        if: always() && steps.run-fuzz-tests.outputs.fuzz-exit-code != '0'
        continue-on-error: true
        uses: ./.github/actions/test-failure-detection
        with:
          output-file: "fuzz-output.log"
          exit-code: ${{ steps.run-fuzz-tests.outputs.fuzz-exit-code }}
          mode: "text"
          failures-file: "fuzz-failures.txt"

      # --------------------------------------------------------------------
      # Create structured fuzz test failure summary for validation workflow
      # --------------------------------------------------------------------
      - name: ðŸ“‹ Create structured fuzz test failure summary
        if: always() && steps.run-fuzz-tests.outputs.fuzz-exit-code != '0'
        continue-on-error: true
        run: |
          echo "ðŸ“‹ Creating structured fuzz test failure summary..."

          # Initialize the JSON structure
          echo '[]' > test-failures-summary.json

          if [ -f fuzz-output.log ]; then
            echo "ðŸ” Processing fuzz test output for structured failures..."

            # Extract failed fuzz tests from output log
            # Pattern: --- FAIL: FuzzTestName (0.34s)
            # Use process substitution to avoid the pipeline subshell issue
            # Filter out nested/indented failures to avoid duplicate counting
            # Only capture top-level fuzz test failures, not nested test failures
            FAILED_TESTS_LIST=$(mktemp)
            # Match pattern: "--- FAIL: FuzzTestName" but exclude lines that contain "#01" or similar nested indicators
            grep -E "^--- FAIL: Fuzz[A-Za-z0-9_]+[[:space:]]*\(" fuzz-output.log | grep -E -v "#[0-9]+" > "$FAILED_TESTS_LIST" || true

            if [[ -s "$FAILED_TESTS_LIST" ]]; then
              echo "ðŸ“‹ Found $(wc -l < "$FAILED_TESTS_LIST") failed fuzz tests to process"

              while IFS= read -r fail_line; do
                echo "ðŸ“„ Processing failure line: $fail_line"

                # Extract test name from the failure line
                # Format: --- FAIL: FuzzGetTokenFromHeader (0.34s)
                if [[ "$fail_line" =~ ^---[[:space:]]*FAIL:[[:space:]]*([^[:space:]]+) ]]; then
                  FUZZ_TEST_NAME="${BASH_REMATCH[1]}"
                  echo "ðŸ“‹ Found failed fuzz test: $FUZZ_TEST_NAME"

                # Extract detailed error output for this specific test
                # Start from the failure line and capture subsequent error details
                ERROR_OUTPUT=$(awk "
                  BEGIN { capture = 0; found_start = 0; }
                  /^--- FAIL: $FUZZ_TEST_NAME/ {
                    found_start = 1;
                    capture = 1;
                    output = \$0;
                    next;
                  }
                  found_start && /^--- FAIL:/ && !/^--- FAIL: $FUZZ_TEST_NAME/ {
                    # Another test failure started, stop capturing
                    exit;
                  }
                  found_start && /^(PASS|ok |FAIL)/ && capture {
                    # Next test result line, stop capturing
                    exit;
                  }
                  found_start && capture && /^[[:space:]]/ {
                    # Indented lines are part of the test output
                    if (length(output) < 2000) {
                      output = output \"\\n\" \$0;
                    }
                  }
                  found_start && capture && /^[[:space:]]*$/ {
                    # Empty line, continue capturing briefly
                    next;
                  }
                  found_start && capture && !/^[[:space:]]/ && !/^(To re-run:|Failing input)/ {
                    # Non-indented line that's not our test, stop capturing unless it's re-run info
                    if (\$0 !~ /^github\.com/) exit;
                  }
                  END {
                    if (found_start) print output;
                  }
                " fuzz-output.log)

                # Get package name from go.mod or use git context fallback
                PACKAGE_NAME="${{ github.repository }}"
                if [[ -f go.mod ]]; then
                  PACKAGE_NAME=$(head -1 go.mod | awk '{print $2}')
                elif [[ -n "${{ github.server_url }}" && -n "${{ github.repository }}" ]]; then
                  # Use GitHub context as fallback
                  PACKAGE_NAME="${{ github.server_url }}/${{ github.repository }}"
                  PACKAGE_NAME=${PACKAGE_NAME#https://}
                fi

                # Calculate elapsed time from the failure line (extract from parentheses)
                ELAPSED="unknown"
                if [[ "$fail_line" =~ \(([0-9.]+[a-z]*)\) ]]; then
                  ELAPSED="${BASH_REMATCH[1]}"
                fi

                # Create JSON entry for this failed fuzz test
                FUZZ_JSON=$(jq -n \
                  --arg pkg "$PACKAGE_NAME" \
                  --arg test "$FUZZ_TEST_NAME" \
                  --arg output "$ERROR_OUTPUT" \
                  --arg elapsed "$ELAPSED" \
                  '{
                    Package: $pkg,
                    Type: "test",
                    failures: [{
                      Test: $test,
                      Elapsed: $elapsed,
                      Output: $output
                    }]
                  }')

                echo "ðŸ“ Adding fuzz test failure to summary:"
                echo "$FUZZ_JSON" | jq '.'

                # Add to summary file
                jq --argjson new_entry "$FUZZ_JSON" '. += [$new_entry]' test-failures-summary.json > test-failures-summary.json.tmp
                mv test-failures-summary.json.tmp test-failures-summary.json
                fi
              done < "$FAILED_TESTS_LIST"

              # Deduplicate fuzz test failures (handle nested test failures with same name)
              # Keep only the entry with the longest elapsed time (parent test)
              if [[ -f test-failures-summary.json ]] && [[ -s test-failures-summary.json ]]; then
                echo "ðŸ”„ Deduplicating fuzz test failures within each package..."

                # Create a deduplicated version by flattening all failures and grouping by test name only
                jq '
                  # First, flatten all failures from all packages
                  [.[] | {Package: .Package, Type: .Type} as $parent | .failures[] | . + {PackageName: $parent.Package, Type: $parent.Type}] |

                  # Then group by test name across all packages
                  group_by(.Test) |

                  # For each test name, pick the entry with longest elapsed time
                  map(
                    sort_by(.Elapsed |
                      if . == "unknown" then -1
                      elif test("^[0-9.]+[a-z]*$") then
                        (. | gsub("[a-z]"; "") | tonumber)
                      else 0
                      end
                    ) |
                    .[-1]
                  ) |

                  # Reconstruct the package structure
                  group_by(.PackageName) |
                  map({
                    Package: .[0].PackageName,
                    Type: .[0].Type,
                    failures: [.[] | {Test: .Test, Elapsed: .Elapsed, Output: .Output}]
                  })
                ' test-failures-summary.json > test-failures-summary.json.dedup

                mv test-failures-summary.json.dedup test-failures-summary.json
                echo "âœ… Deduplicated fuzz test failures - kept entries with longest elapsed time"
              fi

              # Cleanup temp file
              rm -f "$FAILED_TESTS_LIST"
            else
              echo "âš ï¸ No failed fuzz tests found in fuzz-output.log"
            fi

            # Also update the signatures file if it exists but is empty
            if [[ -f fuzz-failures-signatures.json ]] && [[ $(jq 'length' fuzz-failures-signatures.json 2>/dev/null || echo "0") -eq 0 ]]; then
              echo "ðŸ“ Updating empty signatures file with fuzz test failures..."

              # Get package name from go.mod or use git context fallback
              PACKAGE_NAME="${{ github.repository }}"
              if [[ -f go.mod ]]; then
                PACKAGE_NAME=$(head -1 go.mod | awk '{print $2}')
              elif [[ -n "${{ github.server_url }}" && -n "${{ github.repository }}" ]]; then
                # Use GitHub context as fallback
                PACKAGE_NAME="${{ github.server_url }}/${{ github.repository }}"
                PACKAGE_NAME=${PACKAGE_NAME#https://}
              fi

              # Create signature entries from the failures
              SIGNATURE_ENTRIES='[]'
              if [[ -f test-failures-summary.json ]] && [[ $(jq 'length' test-failures-summary.json 2>/dev/null || echo "0") -gt 0 ]]; then
                # Store GitHub Actions values in bash variable for proper escaping
                MATRIX_JOB_ID="fuzz-${{ inputs.primary-runner }}-${{ inputs.go-primary-version }}"

                SIGNATURE_ENTRIES=$(jq --arg matrix_job "$MATRIX_JOB_ID" '[
                  .[] as $parent | $parent.failures[] | {
                    type: "test",
                    package: $parent.Package,
                    test: .Test,
                    output: .Output,
                    signature: ($parent.Package + ":" + .Test),
                    unique_id: (($parent.Package + ":" + .Test) | gsub("[^a-zA-Z0-9_/.-]"; "_")),
                    matrix_job: $matrix_job
                  }
                ]' test-failures-summary.json)
              fi

              # Deduplicate signature entries by test name (handle any remaining duplicates)
              # Group by test name only and prefer entries with valid package names
              SIGNATURE_ENTRIES_DEDUP=$(echo "$SIGNATURE_ENTRIES" | jq '[
                group_by(.test) |
                .[] |
                # Sort by package validity: valid package names last (highest priority)
                sort_by(.package |
                  if test("^[0-9.]+[a-z]*$") then 0    # Elapsed time pattern (lowest priority)
                  else 1                               # Valid package name (highest priority)
                  end
                ) |
                .[-1]  # Take the last entry (valid package name if available)
              ]')

              echo "$SIGNATURE_ENTRIES_DEDUP" > fuzz-failures-signatures.json
              echo "âœ… Updated signatures file with $(echo "$SIGNATURE_ENTRIES_DEDUP" | jq 'length') deduplicated entries"
            fi

            echo "âœ… Structured failure summary created with $(jq 'length' test-failures-summary.json 2>/dev/null || echo "0") fuzz test packages"

            # Debug: Show the created summary
            if [[ -f test-failures-summary.json ]]; then
              echo "ðŸ“Š Final fuzz failure summary:"
              jq . test-failures-summary.json
            fi

            # If no structured failures were found but exit code indicates failure, add generic entry
            if [[ $(jq 'length' test-failures-summary.json 2>/dev/null || echo "0") -eq 0 ]] && [[ "${{ steps.run-fuzz-tests.outputs.fuzz-exit-code }}" != "0" ]]; then
              echo "âš ï¸ Exit code indicates failure but no structured failures found - adding generic fuzz failure entry"

              # Get package name from go.mod or use git context fallback
              PACKAGE_NAME="${{ github.repository }}"
              if [[ -f go.mod ]]; then
                PACKAGE_NAME=$(head -1 go.mod | awk '{print $2}')
              elif [[ -n "${{ github.server_url }}" && -n "${{ github.repository }}" ]]; then
                PACKAGE_NAME="${{ github.server_url }}/${{ github.repository }}"
                PACKAGE_NAME=${PACKAGE_NAME#https://}
              fi

              # Capture last 20 lines of output as error context
              LAST_OUTPUT=$(tail -20 fuzz-output.log 2>/dev/null || echo "No output available")

              jq -n --arg pkg "$PACKAGE_NAME" --arg output "$LAST_OUTPUT" '[{
                Package: $pkg,
                Type: "test",
                failures: [{
                  Test: "fuzz_test_generic_failure",
                  Elapsed: "unknown",
                  Output: $output
                }]
              }]' > test-failures-summary.json

              echo "âœ… Added generic fuzz failure entry to summary"
            fi
          else
            echo "âš ï¸ No fuzz-output.log found, creating minimal failure entry"

            # Create minimal entry when output log is missing
            # Get package name from go.mod or use git context fallback
            PACKAGE_NAME="${{ github.repository }}"
            if [[ -f go.mod ]]; then
              PACKAGE_NAME=$(head -1 go.mod | awk '{print $2}')
            elif [[ -n "${{ github.server_url }}" && -n "${{ github.repository }}" ]]; then
              # Use GitHub context as fallback
              PACKAGE_NAME="${{ github.server_url }}/${{ github.repository }}"
              PACKAGE_NAME=${PACKAGE_NAME#https://}
            fi

            jq -n --arg pkg "$PACKAGE_NAME" '[{
              Package: $pkg,
              Type: "test",
              failures: [{
                Test: "unknown_fuzz_test",
                Elapsed: "unknown",
                Output: "Fuzz test failed but no output log available (exit code: ${{ steps.run-fuzz-tests.outputs.fuzz-exit-code }})"
              }]
            }]' > test-failures-summary.json
          fi

      # --------------------------------------------------------------------
      # Fuzz test failure analysis and reporting
      # --------------------------------------------------------------------
      - name: ðŸš¨ Create Fuzz Test Failure Summary
        if: failure()
        run: |
          echo "## ðŸš¨ Fuzz Test Failures" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **OS**: ${{ inputs.primary-runner }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Go Version**: ${{ inputs.go-primary-version }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ -f fuzz-output.log ]; then
            # Use robust failure detection for fuzz tests
            if command -v detect_failures_from_text >/dev/null 2>&1; then
              # Use robust detection if functions are available
              detect_failures_from_text "fuzz-output.log" "fuzz-failures.txt" || true
              FAIL_COUNT=$(wc -l < fuzz-failures.txt 2>/dev/null || echo "0")
              echo "ðŸ” Using robust fuzz failure detection: $FAIL_COUNT"
            else
              # Fallback: use refined patterns that only match actual test failures
              FAIL_COUNT=$(grep -c -E "^---[[:space:]]*FAIL:[[:space:]]*[A-Za-z][A-Za-z0-9_]*" fuzz-output.log 2>/dev/null || echo "0")
              FAIL_COUNT=$(echo "$FAIL_COUNT" | tr -d '\n\r' | xargs)
              [[ "$FAIL_COUNT" =~ ^[0-9]+$ ]] || FAIL_COUNT=0
              echo "âš ï¸ Using refined patterns for fuzz failure detection: $FAIL_COUNT"
            fi

            # Enhanced panic detection with numeric validation
            PANIC_COUNT=$(grep -c -E "panic:|fatal error:|runtime error:" fuzz-output.log 2>/dev/null || echo "0")
            PANIC_COUNT=$(echo "$PANIC_COUNT" | tr -d '\n\r' | xargs)
            [[ "$PANIC_COUNT" =~ ^[0-9]+$ ]] || PANIC_COUNT=0

            echo "- **Failed Fuzz Tests**: $FAIL_COUNT" >> $GITHUB_STEP_SUMMARY
            echo "- **Panics**: $PANIC_COUNT" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            if [ "$FAIL_COUNT" -gt 0 ]; then
              echo "### ðŸ” Failed Fuzz Test Summary (First 5)" >> $GITHUB_STEP_SUMMARY
              echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
              if [[ -f fuzz-failures.txt ]] && [[ -s fuzz-failures.txt ]]; then
                head -5 fuzz-failures.txt >> $GITHUB_STEP_SUMMARY
              else
                # Fallback: use refined patterns that only match test failures
                grep -E "^---[[:space:]]*FAIL:[[:space:]]*[A-Za-z][A-Za-z0-9_]*" fuzz-output.log | head -5 >> $GITHUB_STEP_SUMMARY
              fi
              echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
            fi

            if [ "$PANIC_COUNT" -gt 0 ]; then
              echo "### ðŸš¨ Fuzz Test Panic/Error Summary" >> $GITHUB_STEP_SUMMARY
              echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
              # Enhanced panic/error detection patterns
              grep -A 2 -B 1 -E "panic:|fatal error:|runtime error:" fuzz-output.log | head -20 >> $GITHUB_STEP_SUMMARY
              echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "âš ï¸ Fuzz test output log not found" >> $GITHUB_STEP_SUMMARY
          fi

      # --------------------------------------------------------------------
      # Create GitHub annotations for fuzz test failures
      # --------------------------------------------------------------------
      - name: ðŸ“‹ Annotate Key Fuzz Test Failures
        if: failure()
        run: |
          if [ -f fuzz-output.log ]; then
            echo "::group::ðŸ“‹ Fuzz Test Failure Analysis (Enhanced)"

            # Count and report overall statistics using robust detection
            if [[ -f fuzz-failures.txt ]] && [[ -s fuzz-failures.txt ]]; then
              FAIL_COUNT=$(wc -l < fuzz-failures.txt 2>/dev/null || echo "0")
              echo "ðŸ” Using robust fuzz failure count for annotation: $FAIL_COUNT"
            else
              # Fallback: use refined patterns that only match test failures
              FAIL_COUNT=$(grep -c -E "^---[[:space:]]*FAIL:[[:space:]]*[A-Za-z][A-Za-z0-9_]*" fuzz-output.log 2>/dev/null || echo "0")
              FAIL_COUNT=$(echo "$FAIL_COUNT" | tr -d '\n\r' | xargs)
              [[ "$FAIL_COUNT" =~ ^[0-9]+$ ]] || FAIL_COUNT=0
              echo "âš ï¸ Using refined patterns for fuzz annotation: $FAIL_COUNT"
            fi

            # Enhanced panic detection with numeric validation
            PANIC_COUNT=$(grep -c -E "panic:|fatal error:|runtime error:" fuzz-output.log 2>/dev/null || echo "0")
            PANIC_COUNT=$(echo "$PANIC_COUNT" | tr -d '\n\r' | xargs)
            [[ "$PANIC_COUNT" =~ ^[0-9]+$ ]] || PANIC_COUNT=0

            echo "::error title=Fuzz Test Suite Failed::$FAIL_COUNT fuzz tests failed, $PANIC_COUNT panics/errors detected on ${{ inputs.primary-runner }} Go ${{ inputs.go-primary-version }}"

            # Annotate first 3 failed fuzz tests using robust detection
            if [[ "$FAIL_COUNT" -gt 0 ]]; then
              if [[ -f fuzz-failures.txt ]] && [[ -s fuzz-failures.txt ]]; then
                head -3 fuzz-failures.txt | while IFS= read -r line; do
                  echo "::error title=Failed Fuzz Test::$line"
                done
              else
                # Fallback: use refined patterns that only match test failures
                grep -E "^---[[:space:]]*FAIL:[[:space:]]*[A-Za-z][A-Za-z0-9_]*" fuzz-output.log | head -3 | while IFS= read -r line; do
                  echo "::error title=Failed Fuzz Test::$line"
                done
              fi
            fi

            # Annotate panics/errors with enhanced patterns
            if [ "$PANIC_COUNT" -gt 0 ]; then
              grep -B 1 -E "panic:|fatal error:|runtime error:" fuzz-output.log | head -2 | while IFS= read -r line; do
                echo "::error title=Fuzz Test Panic/Error::$line"
              done
            fi

            echo "::endgroup::"
          fi

      # --------------------------------------------------------------------
      # Generate fuzz test statistics using composite action
      # --------------------------------------------------------------------
      - name: ðŸ“Š Calculate fuzz test statistics
        id: fuzz-summary
        if: always()
        uses: ./.github/actions/test-statistics
        with:
          matrix-name: "Fuzz Tests (${{ inputs.primary-runner }})"
          matrix-os: ${{ inputs.primary-runner }}
          matrix-go-version: ${{ inputs.go-primary-version }}
          test-exit-code: ${{ steps.run-fuzz-tests.outputs.fuzz-exit-code || '0' }}
          output-mode: "FULL"
          job-status: ${{ job.status }}
          test-start-time: ${{ steps.fuzz-timer.outputs.fuzz-start || '0' }}
          race-detection-enabled: "false"
          code-coverage-enabled: "false"
          fuzz-run: "true"
          failures-file: "fuzz-failures.txt"
          output-file: "fuzz-output.log"

      # --------------------------------------------------------------------
      # Collect performance cache statistics
      # --------------------------------------------------------------------
      - name: ðŸ“Š Collect performance cache statistics
        uses: ./.github/actions/collect-cache-stats
        with:
          workflow-name: fuzz
          job-name: fuzz-tests
          os: ${{ inputs.primary-runner }}
          go-version: ${{ inputs.go-primary-version }}
          cache-prefix: cache-stats
          gomod-cache-hit: ${{ steps.setup-go-fuzz.outputs.module-cache-hit }}
          gobuild-cache-hit: ${{ steps.setup-go-fuzz.outputs.build-cache-hit }}

      # --------------------------------------------------------------------
      # Upload performance cache statistics for completion report
      # --------------------------------------------------------------------
      - name: ðŸ“¤ Upload performance cache statistics
        if: always()
        uses: ./.github/actions/upload-statistics
        with:
          artifact-name: cache-stats-fuzz
          artifact-path: cache-stats-fuzz.json
          retention-days: "1"

      # --------------------------------------------------------------------
      # Upload fuzz test outputs and failures for validation
      # --------------------------------------------------------------------
      - name: ðŸ“¤ Upload fuzz test outputs
        if: always()
        uses: actions/upload-artifact@330a01c490aca151604b8cf639adc76d48f6c5d4 # v5.0.0
        with:
          name: test-results-fuzz-${{ inputs.primary-runner }}-${{ inputs.go-primary-version }}
          path: |
            fuzz-output.log
            fuzz-failures.txt
            fuzz-failures-detailed.txt
            test-failures-summary.json
            fuzz-failures-signatures.json
          retention-days: 1
          if-no-files-found: ignore

      # --------------------------------------------------------------------
      # Upload fuzz test statistics for completion report
      # --------------------------------------------------------------------
      - name: ðŸ“¤ Upload fuzz test statistics
        if: always() && steps.fuzz-summary.outputs.statistics-file != ''
        uses: ./.github/actions/upload-statistics
        with:
          artifact-name: test-stats-fuzz-${{ inputs.primary-runner }}-${{ inputs.go-primary-version }}
          artifact-path: ${{ steps.fuzz-summary.outputs.statistics-file }}
          retention-days: "1"
          if-no-files-found: "ignore"
