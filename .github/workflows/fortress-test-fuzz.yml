# ------------------------------------------------------------------------------------
#  Fuzz Testing (Reusable Workflow) (GoFortress)
#
#  Purpose: Execute Go fuzz tests to detect edge cases and potential security
#  vulnerabilities through automated input generation and testing.
#
#  This workflow handles:
#    - Fuzz test execution on primary runner with primary Go version
#    - Panic and error detection from fuzz test output
#    - Failure analysis and structured reporting
#    - Statistics collection and artifact uploading
#    - Cache performance tracking
#
#  Maintainer: @mrz1836
#
# ------------------------------------------------------------------------------------

name: GoFortress (Fuzz Tests)

on:
  workflow_call:
    inputs:
      env-json:
        description: "JSON string of environment variables"
        required: true
        type: string
      primary-runner:
        description: "Primary runner OS"
        required: true
        type: string
      go-primary-version:
        description: "Primary Go version"
        required: true
        type: string
      go-secondary-version:
        description: "Secondary Go version"
        required: true
        type: string
      fuzz-testing-enabled:
        description: "Whether fuzz testing is enabled"
        required: true
        type: string

# Security: Restrictive default permissions with job-level overrides for least privilege access
permissions:
  contents: read

jobs:
  # ----------------------------------------------------------------------------------
  # Fuzz Testing
  # ----------------------------------------------------------------------------------
  fuzz-tests:
    name: üß™ Fuzz Tests
    if: inputs.fuzz-testing-enabled == 'true'
    timeout-minutes: 15 # Fuzz tests have shorter timeout
    permissions:
      contents: read # Read repository content for testing
    runs-on: ${{ inputs.primary-runner }}

    steps:
      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      # Checkout code (required for local actions)
      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      - name: üì• Checkout code
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      # Parse environment variables
      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      - name: üîß Parse environment variables
        uses: ./.github/actions/parse-env
        with:
          env-json: ${{ inputs.env-json }}

      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      # Setup Go with caching and version management (primary version only)
      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      - name: üèóÔ∏è Setup Go with Cache
        id: setup-go-fuzz
        uses: ./.github/actions/setup-go-with-cache
        with:
          go-version: ${{ inputs.go-primary-version }}
          matrix-os: ${{ inputs.primary-runner }}
          go-primary-version: ${{ inputs.go-primary-version }}
          go-secondary-version: ${{ inputs.go-secondary-version }}

      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      # Setup MAGE-X (required for magex test commands)
      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      - name: üîß Setup MAGE-X
        uses: ./.github/actions/setup-magex
        with:
          magex-version: ${{ env.MAGE_X_VERSION }}
          runner-os: ${{ inputs.primary-runner }}

      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      # Start fuzz test timer
      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      - name: ‚è±Ô∏è Start fuzz test timer
        id: fuzz-timer
        run: |
          echo "fuzz-start=$(date +%s)" >> $GITHUB_OUTPUT
          echo "üïí Fuzz test timer started at: $(date -u +%Y-%m-%dT%H:%M:%SZ)"

      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      # Setup fuzz test failure detection functions
      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      - name: üîß Setup failure detection for fuzz tests
        uses: ./.github/actions/test-failure-detection
        with:
          output-file: "fuzz-output.log"
          mode: "text"

      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      # Run fuzz tests
      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      - name: üß™ Run fuzz tests
        id: run-fuzz-tests
        continue-on-error: true
        run: |
          echo "üß™ Running fuzz tests in parallel..."
          FUZZ_TIMEOUT="${TEST_TIMEOUT_FUZZ:-5m}"
          magex test:fuzz time=5s -timeout $FUZZ_TIMEOUT 2>&1 | tee fuzz-output.log
          FUZZ_EXIT_CODE=${PIPESTATUS[0]}
          echo "üîß Fuzz tests completed with timeout: $FUZZ_TIMEOUT"

          # Store the exit code for later steps
          echo "FUZZ_EXIT_CODE=$FUZZ_EXIT_CODE" >> $GITHUB_ENV
          echo "fuzz-exit-code=$FUZZ_EXIT_CODE" >> $GITHUB_OUTPUT

          if [[ $FUZZ_EXIT_CODE -eq 0 ]]; then
            echo "‚úÖ Fuzz tests completed successfully"
          else
            echo "‚ùå Fuzz tests failed with exit code $FUZZ_EXIT_CODE"
          fi

      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      # Analyze fuzz test failures using detection functions
      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      - name: üîç Analyze fuzz test failures
        if: always() && steps.run-fuzz-tests.outputs.fuzz-exit-code != '0'
        continue-on-error: true
        uses: ./.github/actions/test-failure-detection
        with:
          output-file: "fuzz-output.log"
          exit-code: ${{ steps.run-fuzz-tests.outputs.fuzz-exit-code }}
          mode: "text"
          failures-file: "fuzz-failures.txt"

      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      # Create structured fuzz test failure summary for validation workflow
      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      - name: üìã Create structured fuzz test failure summary
        if: always() && steps.run-fuzz-tests.outputs.fuzz-exit-code != '0'
        continue-on-error: true
        run: |
          echo "üìã Creating structured fuzz test failure summary..."

          # Initialize the JSON structure
          echo '[]' > test-failures-summary.json

          if [ -f fuzz-output.log ]; then
            echo "üîç Processing fuzz test output for structured failures..."

            # Extract failed fuzz tests from output log
            # Pattern: --- FAIL: FuzzTestName (0.34s)
            grep -E "^--- FAIL: Fuzz[A-Za-z0-9_]+" fuzz-output.log | while IFS= read -r fail_line; do
              echo "üìÑ Processing failure line: $fail_line"

              # Extract test name from the failure line
              # Format: --- FAIL: FuzzGetTokenFromHeader (0.34s)
              if [[ "$fail_line" =~ ^---[[:space:]]*FAIL:[[:space:]]*([^[:space:]]+) ]]; then
                FUZZ_TEST_NAME="${BASH_REMATCH[1]}"
                echo "üìã Found failed fuzz test: $FUZZ_TEST_NAME"

                # Extract detailed error output for this specific test
                # Start from the failure line and capture subsequent error details
                ERROR_OUTPUT=$(awk "
                  BEGIN { capture = 0; found_start = 0; }
                  /^--- FAIL: $FUZZ_TEST_NAME/ {
                    found_start = 1;
                    capture = 1;
                    output = \$0;
                    next;
                  }
                  found_start && /^--- FAIL:/ && !/^--- FAIL: $FUZZ_TEST_NAME/ {
                    # Another test failure started, stop capturing
                    exit;
                  }
                  found_start && /^(PASS|ok |FAIL)/ && capture {
                    # Next test result line, stop capturing
                    exit;
                  }
                  found_start && capture && /^[[:space:]]/ {
                    # Indented lines are part of the test output
                    if (length(output) < 2000) {
                      output = output \"\\n\" \$0;
                    }
                  }
                  found_start && capture && /^[[:space:]]*$/ {
                    # Empty line, continue capturing briefly
                    next;
                  }
                  found_start && capture && !/^[[:space:]]/ && !/^(To re-run:|Failing input)/ {
                    # Non-indented line that's not our test, stop capturing unless it's re-run info
                    if (\$0 !~ /^github\.com/) exit;
                  }
                  END {
                    if (found_start) print output;
                  }
                " fuzz-output.log)

                # Get package name from go.mod or use git context fallback
                PACKAGE_NAME="${{ github.repository }}"
                if [[ -f go.mod ]]; then
                  PACKAGE_NAME=$(head -1 go.mod | awk '{print $2}')
                elif [[ -n "${{ github.server_url }}" && -n "${{ github.repository }}" ]]; then
                  # Use GitHub context as fallback
                  PACKAGE_NAME="${{ github.server_url }}/${{ github.repository }}"
                  PACKAGE_NAME=${PACKAGE_NAME#https://}
                fi

                # Calculate elapsed time from the failure line (extract from parentheses)
                ELAPSED="unknown"
                if [[ "$fail_line" =~ \(([0-9.]+[a-z]*)\) ]]; then
                  ELAPSED="${BASH_REMATCH[1]}"
                fi

                # Create JSON entry for this failed fuzz test
                FUZZ_JSON=$(jq -n \
                  --arg pkg "$PACKAGE_NAME" \
                  --arg test "$FUZZ_TEST_NAME" \
                  --arg output "$ERROR_OUTPUT" \
                  --arg elapsed "$ELAPSED" \
                  '{
                    Package: $pkg,
                    Type: "test",
                    failures: [{
                      Test: $test,
                      Elapsed: $elapsed,
                      Output: $output
                    }]
                  }')

                echo "üìù Adding fuzz test failure to summary:"
                echo "$FUZZ_JSON" | jq '.'

                # Add to summary file
                jq --argjson new_entry "$FUZZ_JSON" '. += [$new_entry]' test-failures-summary.json > test-failures-summary.json.tmp
                mv test-failures-summary.json.tmp test-failures-summary.json
              fi
            done

            # Also update the signatures file if it exists but is empty
            if [[ -f fuzz-failures-signatures.json ]] && [[ $(jq 'length' fuzz-failures-signatures.json 2>/dev/null || echo "0") -eq 0 ]]; then
              echo "üìù Updating empty signatures file with fuzz test failures..."

              # Get package name from go.mod or use git context fallback
              PACKAGE_NAME="${{ github.repository }}"
              if [[ -f go.mod ]]; then
                PACKAGE_NAME=$(head -1 go.mod | awk '{print $2}')
              elif [[ -n "${{ github.server_url }}" && -n "${{ github.repository }}" ]]; then
                # Use GitHub context as fallback
                PACKAGE_NAME="${{ github.server_url }}/${{ github.repository }}"
                PACKAGE_NAME=${PACKAGE_NAME#https://}
              fi

              # Create signature entries from the failures
              SIGNATURE_ENTRIES='[]'
              if [[ -f test-failures-summary.json ]] && [[ $(jq 'length' test-failures-summary.json 2>/dev/null || echo "0") -gt 0 ]]; then
                # Store GitHub Actions values in bash variable for proper escaping
                MATRIX_JOB_ID="fuzz-${{ inputs.primary-runner }}-${{ inputs.go-primary-version }}"

                SIGNATURE_ENTRIES=$(jq --arg matrix_job "$MATRIX_JOB_ID" '[
                  .[] as $parent | $parent.failures[] | {
                    type: "test",
                    package: $parent.Package,
                    test: .Test,
                    output: .Output,
                    signature: ($parent.Package + ":" + .Test),
                    unique_id: (($parent.Package + ":" + .Test) | gsub("[^a-zA-Z0-9_/.-]"; "_")),
                    matrix_job: $matrix_job
                  }
                ]' test-failures-summary.json)
              fi

              echo "$SIGNATURE_ENTRIES" > fuzz-failures-signatures.json
              echo "‚úÖ Updated signatures file with $(echo "$SIGNATURE_ENTRIES" | jq 'length') entries"
            fi

            echo "‚úÖ Structured failure summary created with $(jq 'length' test-failures-summary.json 2>/dev/null || echo "0") fuzz test packages"

            # Debug: Show the created summary
            if [[ -f test-failures-summary.json ]]; then
              echo "üìä Final fuzz failure summary:"
              jq . test-failures-summary.json
            fi
          else
            echo "‚ö†Ô∏è No fuzz-output.log found, creating minimal failure entry"

            # Create minimal entry when output log is missing
            # Get package name from go.mod or use git context fallback
            PACKAGE_NAME="${{ github.repository }}"
            if [[ -f go.mod ]]; then
              PACKAGE_NAME=$(head -1 go.mod | awk '{print $2}')
            elif [[ -n "${{ github.server_url }}" && -n "${{ github.repository }}" ]]; then
              # Use GitHub context as fallback
              PACKAGE_NAME="${{ github.server_url }}/${{ github.repository }}"
              PACKAGE_NAME=${PACKAGE_NAME#https://}
            fi

            jq -n --arg pkg "$PACKAGE_NAME" '[{
              Package: $pkg,
              Type: "test",
              failures: [{
                Test: "unknown_fuzz_test",
                Elapsed: "unknown",
                Output: "Fuzz test failed but no output log available (exit code: ${{ steps.run-fuzz-tests.outputs.fuzz-exit-code }})"
              }]
            }]' > test-failures-summary.json
          fi

      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      # Fuzz test failure analysis and reporting
      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      - name: üö® Create Fuzz Test Failure Summary
        if: failure()
        run: |
          echo "## üö® Fuzz Test Failures" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **OS**: ${{ inputs.primary-runner }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Go Version**: ${{ inputs.go-primary-version }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ -f fuzz-output.log ]; then
            # Use robust failure detection for fuzz tests
            if command -v detect_failures_from_text >/dev/null 2>&1; then
              # Use robust detection if functions are available
              detect_failures_from_text "fuzz-output.log" "fuzz-failures.txt" || true
              FAIL_COUNT=$(wc -l < fuzz-failures.txt 2>/dev/null || echo "0")
              echo "üîç Using robust fuzz failure detection: $FAIL_COUNT"
            else
              # Fallback: use enhanced patterns with numeric validation
              FAIL_COUNT=$(grep -c -E "^(FAIL|---[[:space:]]*FAIL|--[[:space:]]*FAIL|\[?FAIL\]?)[[:space:]:.]" fuzz-output.log 2>/dev/null || echo "0")
              FAIL_COUNT=$(echo "$FAIL_COUNT" | tr -d '\n\r' | xargs)
              [[ "$FAIL_COUNT" =~ ^[0-9]+$ ]] || FAIL_COUNT=0
              echo "‚ö†Ô∏è Using enhanced patterns for fuzz failure detection: $FAIL_COUNT"
            fi

            # Enhanced panic detection with numeric validation
            PANIC_COUNT=$(grep -c -E "panic:|fatal error:|runtime error:" fuzz-output.log 2>/dev/null || echo "0")
            PANIC_COUNT=$(echo "$PANIC_COUNT" | tr -d '\n\r' | xargs)
            [[ "$PANIC_COUNT" =~ ^[0-9]+$ ]] || PANIC_COUNT=0

            echo "- **Failed Fuzz Tests**: $FAIL_COUNT" >> $GITHUB_STEP_SUMMARY
            echo "- **Panics**: $PANIC_COUNT" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            if [ "$FAIL_COUNT" -gt 0 ]; then
              echo "### üîç Failed Fuzz Test Summary (First 5)" >> $GITHUB_STEP_SUMMARY
              echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
              if [[ -f fuzz-failures.txt ]] && [[ -s fuzz-failures.txt ]]; then
                head -5 fuzz-failures.txt >> $GITHUB_STEP_SUMMARY
              else
                # Fallback: use enhanced patterns
                grep -E "^(FAIL|---[[:space:]]*FAIL|--[[:space:]]*FAIL|\[?FAIL\]?)[[:space:]:.]" fuzz-output.log | head -5 >> $GITHUB_STEP_SUMMARY
              fi
              echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
            fi

            if [ "$PANIC_COUNT" -gt 0 ]; then
              echo "### üö® Fuzz Test Panic/Error Summary" >> $GITHUB_STEP_SUMMARY
              echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
              # Enhanced panic/error detection patterns
              grep -A 2 -B 1 -E "panic:|fatal error:|runtime error:" fuzz-output.log | head -20 >> $GITHUB_STEP_SUMMARY
              echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "‚ö†Ô∏è Fuzz test output log not found" >> $GITHUB_STEP_SUMMARY
          fi

      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      # Create GitHub annotations for fuzz test failures
      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      - name: üìã Annotate Key Fuzz Test Failures
        if: failure()
        run: |
          if [ -f fuzz-output.log ]; then
            echo "::group::üìã Fuzz Test Failure Analysis (Enhanced)"

            # Count and report overall statistics using robust detection
            if [[ -f fuzz-failures.txt ]] && [[ -s fuzz-failures.txt ]]; then
              FAIL_COUNT=$(wc -l < fuzz-failures.txt 2>/dev/null || echo "0")
              echo "üîç Using robust fuzz failure count for annotation: $FAIL_COUNT"
            else
              # Fallback: use enhanced patterns with numeric validation
              FAIL_COUNT=$(grep -c -E "^(FAIL|---[[:space:]]*FAIL|--[[:space:]]*FAIL|\[?FAIL\]?)[[:space:]:.]" fuzz-output.log 2>/dev/null || echo "0")
              FAIL_COUNT=$(echo "$FAIL_COUNT" | tr -d '\n\r' | xargs)
              [[ "$FAIL_COUNT" =~ ^[0-9]+$ ]] || FAIL_COUNT=0
              echo "‚ö†Ô∏è Using enhanced patterns for fuzz annotation: $FAIL_COUNT"
            fi

            # Enhanced panic detection with numeric validation
            PANIC_COUNT=$(grep -c -E "panic:|fatal error:|runtime error:" fuzz-output.log 2>/dev/null || echo "0")
            PANIC_COUNT=$(echo "$PANIC_COUNT" | tr -d '\n\r' | xargs)
            [[ "$PANIC_COUNT" =~ ^[0-9]+$ ]] || PANIC_COUNT=0

            echo "::error title=Fuzz Test Suite Failed::$FAIL_COUNT fuzz tests failed, $PANIC_COUNT panics/errors detected on ${{ inputs.primary-runner }} Go ${{ inputs.go-primary-version }}"

            # Annotate first 3 failed fuzz tests using robust detection
            if [[ "$FAIL_COUNT" -gt 0 ]]; then
              if [[ -f fuzz-failures.txt ]] && [[ -s fuzz-failures.txt ]]; then
                head -3 fuzz-failures.txt | while IFS= read -r line; do
                  echo "::error title=Failed Fuzz Test::$line"
                done
              else
                # Fallback: use enhanced patterns
                grep -E "^(FAIL|---[[:space:]]*FAIL|--[[:space:]]*FAIL|\[?FAIL\]?)[[:space:]:.]" fuzz-output.log | head -3 | while IFS= read -r line; do
                  echo "::error title=Failed Fuzz Test::$line"
                done
              fi
            fi

            # Annotate panics/errors with enhanced patterns
            if [ "$PANIC_COUNT" -gt 0 ]; then
              grep -B 1 -E "panic:|fatal error:|runtime error:" fuzz-output.log | head -2 | while IFS= read -r line; do
                echo "::error title=Fuzz Test Panic/Error::$line"
              done
            fi

            echo "::endgroup::"
          fi

      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      # Generate fuzz test statistics using composite action
      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      - name: üìä Calculate fuzz test statistics
        id: fuzz-summary
        if: always()
        uses: ./.github/actions/test-statistics
        with:
          matrix-name: "Fuzz Tests (${{ inputs.primary-runner }})"
          matrix-os: ${{ inputs.primary-runner }}
          matrix-go-version: ${{ inputs.go-primary-version }}
          test-exit-code: ${{ steps.run-fuzz-tests.outputs.fuzz-exit-code || '0' }}
          output-mode: "FULL"
          job-status: ${{ job.status }}
          test-start-time: ${{ steps.fuzz-timer.outputs.fuzz-start || '0' }}
          race-detection-enabled: "false"
          code-coverage-enabled: "false"
          fuzz-run: "true"
          failures-file: "fuzz-failures.txt"
          output-file: "fuzz-output.log"

      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      # Collect performance cache statistics
      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      - name: üìä Collect performance cache statistics
        uses: ./.github/actions/collect-cache-stats
        with:
          workflow-name: fuzz
          job-name: fuzz-tests
          os: ${{ inputs.primary-runner }}
          go-version: ${{ inputs.go-primary-version }}
          cache-prefix: cache-stats
          gomod-cache-hit: ${{ steps.setup-go-fuzz.outputs.module-cache-hit }}
          gobuild-cache-hit: ${{ steps.setup-go-fuzz.outputs.build-cache-hit }}

      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      # Upload performance cache statistics for completion report
      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      - name: üì§ Upload performance cache statistics
        if: always()
        uses: ./.github/actions/upload-statistics
        with:
          artifact-name: cache-stats-fuzz
          artifact-path: cache-stats-fuzz.json
          retention-days: "1"

      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      # Upload fuzz test outputs and failures for validation
      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      - name: üì§ Upload fuzz test outputs
        if: always()
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: test-results-fuzz-${{ inputs.primary-runner }}-${{ inputs.go-primary-version }}
          path: |
            fuzz-output.log
            fuzz-failures.txt
            fuzz-failures-detailed.txt
            test-failures-summary.json
            fuzz-failures-signatures.json
          retention-days: 1
          if-no-files-found: ignore

      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      # Upload fuzz test statistics for completion report
      # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
      - name: üì§ Upload fuzz test statistics
        if: always() && steps.fuzz-summary.outputs.statistics-file != ''
        uses: ./.github/actions/upload-statistics
        with:
          artifact-name: test-stats-fuzz-${{ inputs.primary-runner }}-${{ inputs.go-primary-version }}
          artifact-path: ${{ steps.fuzz-summary.outputs.statistics-file }}
          retention-days: "1"
          if-no-files-found: "ignore"
