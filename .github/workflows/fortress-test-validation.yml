# ------------------------------------------------------------------------------------
#  Test Results Validation (Reusable Workflow) (GoFortress)
#
#  Purpose: Validate and aggregate test results from all test workflows including
#  matrix tests, fuzz tests, and provide comprehensive failure analysis.
#
#  This workflow handles:
#    - Downloading test result artifacts from all test workflows
#    - Validating test statistics and exit codes
#    - Aggregating failure information across test types
#    - Providing detailed failure analysis with smart filtering
#    - Creating comprehensive validation reports
#
#  Maintainer: @mrz1836
#
# ------------------------------------------------------------------------------------

name: GoFortress (Test Validation)

on:
  workflow_call:
    inputs:
      env-json:
        description: "JSON string of environment variables"
        required: true
        type: string
      primary-runner:
        description: "Primary runner OS"
        required: true
        type: string
      fuzz-testing-enabled:
        description: "Whether fuzz testing is enabled"
        required: true
        type: string

# Security: Restrictive default permissions with job-level overrides for least privilege access
permissions:
  contents: read
  actions: read # Required for artifact downloads

jobs:
  # ----------------------------------------------------------------------------------
  # Validate Test Results
  # ----------------------------------------------------------------------------------
  validate-test-results:
    name: üîç Validate Test Results
    if: always() # Always run to check results even if jobs continued on error
    permissions:
      contents: read # Read repository content for validation
      actions: read # Read workflow artifacts for download
    runs-on: ${{ inputs.primary-runner }}

    steps:
      # --------------------------------------------------------------------
      # Checkout code (required for local actions)
      # --------------------------------------------------------------------
      - name: üì• Checkout code
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      # --------------------------------------------------------------------
      # Parse environment variables
      # --------------------------------------------------------------------
      - name: üîß Parse environment variables
        uses: ./.github/actions/parse-env
        with:
          env-json: ${{ inputs.env-json }}

      # --------------------------------------------------------------------
      # Download unit test result artifacts with resilience
      # --------------------------------------------------------------------
      - name: üì• Download unit test results (with retry)
        uses: ./.github/actions/download-artifact-resilient
        with:
          pattern: "test-results-unit-*"
          path: test-results/
          merge-multiple: true
          max-retries: ${{ env.ARTIFACT_DOWNLOAD_RETRIES }}
          retry-delay: ${{ env.ARTIFACT_DOWNLOAD_RETRY_DELAY }}
          timeout: ${{ env.ARTIFACT_DOWNLOAD_TIMEOUT }}
          continue-on-error: ${{ env.ARTIFACT_DOWNLOAD_CONTINUE_ON_ERROR }}

      - name: üì• Download test statistics (with retry)
        uses: ./.github/actions/download-artifact-resilient
        with:
          pattern: "test-stats-*"
          path: test-results/
          merge-multiple: true
          max-retries: ${{ env.ARTIFACT_DOWNLOAD_RETRIES }}
          retry-delay: ${{ env.ARTIFACT_DOWNLOAD_RETRY_DELAY }}
          timeout: ${{ env.ARTIFACT_DOWNLOAD_TIMEOUT }}
          continue-on-error: ${{ env.ARTIFACT_DOWNLOAD_CONTINUE_ON_ERROR }}

      - name: üì• Download fuzz results (if enabled, with retry)
        if: inputs.fuzz-testing-enabled == 'true'
        uses: ./.github/actions/download-artifact-resilient
        with:
          pattern: "test-results-fuzz-*"
          path: test-results/
          merge-multiple: true
          max-retries: ${{ env.ARTIFACT_DOWNLOAD_RETRIES }}
          retry-delay: ${{ env.ARTIFACT_DOWNLOAD_RETRY_DELAY }}
          timeout: ${{ env.ARTIFACT_DOWNLOAD_TIMEOUT }}
          continue-on-error: ${{ env.ARTIFACT_DOWNLOAD_CONTINUE_ON_ERROR }}

      # --------------------------------------------------------------------
      # Flatten downloaded artifacts to expected directory structure
      # --------------------------------------------------------------------
      - name: üóÇÔ∏è Flatten downloaded artifacts
        if: always()
        run: |
          echo "üóÇÔ∏è Flattening downloaded artifacts..."

          # Process test statistics (move from subdirectories to test-results/)
          if [ -d "test-results/" ]; then
            echo "üìã Directory structure before flattening:"
            find test-results/ -name "*.json" -type f | head -10 | sed 's/^/  ‚Ä¢ /' || echo "  No JSON files found"

            # Process all JSON files including signatures
            find test-results/ -name "*.json" -type f | while read -r file; do
              filename=$(basename "$file")
              echo "Moving $file to test-results/$filename"
              cp "$file" "test-results/$filename"
            done

            echo "üìã Available files after flattening:"
            echo "  ‚Ä¢ Statistics files:"
            ls -la test-results/*-stats-*.json 2>/dev/null || echo "    No statistics files found"
            echo "  ‚Ä¢ Signature files:"
            ls -la test-results/*test-failures-signatures.json 2>/dev/null || echo "    No signature files found"
            echo "  ‚Ä¢ Summary files:"
            ls -la test-results/*test-failures-summary.json 2>/dev/null || echo "    No summary files found"
          else
            echo "‚ö†Ô∏è No test-results directory found"
          fi

      # --------------------------------------------------------------------
      # Deduplicate test failures across matrix jobs
      # --------------------------------------------------------------------
      - name: üîÑ Deduplicate test failures
        run: |
          echo "üîÑ Deduplicating test failures across matrix jobs..."

          # Initialize deduplicated results
          echo '[]' > deduplicated-failures.json

          TOTAL_RAW_FAILURES=0
          TOTAL_UNIQUE_FAILURES=0

          # Collect all signature files from different matrix jobs (including subdirectories)
          # Check for both regular test signatures and fuzz test signatures
          SIGNATURE_PATTERN_1="test-results/*test-failures-signatures.json"
          SIGNATURE_PATTERN_2="test-results/*fuzz-failures-signatures.json"

          if compgen -G "$SIGNATURE_PATTERN_1" >/dev/null 2>&1 || compgen -G "$SIGNATURE_PATTERN_2" >/dev/null 2>&1; then
            echo "üìã Found failure signature files:"
            ls -la test-results/*test-failures-signatures.json test-results/*fuzz-failures-signatures.json 2>/dev/null || echo "No signature files found"

            # Debug: Show content of signature files
            echo "üîç Debugging signature file contents:"
            for sig_file in test-results/*test-failures-signatures.json test-results/*fuzz-failures-signatures.json; do
              if [[ -f "$sig_file" ]]; then
                echo "üìÑ File: $sig_file"
                echo "  ‚Ä¢ File size: $(wc -c < "$sig_file") bytes"
                echo "  ‚Ä¢ First few lines:"
                head -5 "$sig_file" | sed 's/^/    /' || echo "    (empty or invalid)"
              fi
            done

            # Merge all signature files and deduplicate by signature
            for sig_file in test-results/*test-failures-signatures.json test-results/*fuzz-failures-signatures.json; do
              if [[ -s "$sig_file" ]]; then
                echo "üìÑ Processing: $sig_file"
                RAW_COUNT=$(jq 'length' "$sig_file" 2>/dev/null || echo "0")
                TOTAL_RAW_FAILURES=$((TOTAL_RAW_FAILURES + RAW_COUNT))
                echo "  ‚Ä¢ Raw failures in this file: $RAW_COUNT"
              else
                echo "üìÑ Skipping empty file: $sig_file"
              fi
            done

            # Combine all signature files and deduplicate
            # Create a list of all signature files that exist
            SIGNATURE_FILES=""
            for pattern in test-results/*test-failures-signatures.json test-results/*fuzz-failures-signatures.json; do
              if [[ -f "$pattern" ]]; then
                SIGNATURE_FILES="$SIGNATURE_FILES $pattern"
              fi
            done

            if [[ -n "$SIGNATURE_FILES" ]]; then
              jq -s 'add | group_by(.signature) | map({
                signature: .[0].signature,
                unique_id: .[0].unique_id,
                type: .[0].type,
                package: .[0].package,
                test: .[0].test,
                output: .[0].output,
                occurrences: length,
                matrix_jobs: [.[].matrix_job // "unknown"] | unique
              })' $SIGNATURE_FILES > deduplicated-failures.json 2>/dev/null || echo '[]' > deduplicated-failures.json
            else
              echo '[]' > deduplicated-failures.json
            fi

            TOTAL_UNIQUE_FAILURES=$(jq 'length' deduplicated-failures.json 2>/dev/null || echo "0")

            echo "üìä Deduplication Results:"
            echo "  ‚Ä¢ Total raw failure reports: $TOTAL_RAW_FAILURES"
            echo "  ‚Ä¢ Total unique failures: $TOTAL_UNIQUE_FAILURES"

            if [[ $TOTAL_RAW_FAILURES -gt $TOTAL_UNIQUE_FAILURES ]]; then
              DUPLICATE_COUNT=$((TOTAL_RAW_FAILURES - TOTAL_UNIQUE_FAILURES))
              echo "  ‚Ä¢ Duplicates eliminated: $DUPLICATE_COUNT"
            fi
          else
            echo "‚ö†Ô∏è No signature files found - falling back to legacy detection"
            TOTAL_RAW_FAILURES=0
            TOTAL_UNIQUE_FAILURES=0

            # Count failures from legacy summary files when signature files are missing
            if compgen -G "test-results/*test-failures-summary.json" >/dev/null 2>&1; then
              echo "üìã Counting failures from legacy summary files..."
              for summary_file in test-results/*test-failures-summary.json; do
                if [[ -s "$summary_file" ]]; then
                  echo "üìÑ Processing legacy file: $summary_file"
                  # Count both test and build failures from the summary file
                  LEGACY_TEST_FAILURES=$(jq '[.[] | select(.Type == "test" or .Type == null) | .failures[]?] | length' "$summary_file" 2>/dev/null || echo "0")
                  LEGACY_BUILD_FAILURES=$(jq '[.[] | select(.Type == "build")] | length' "$summary_file" 2>/dev/null || echo "0")
                  LEGACY_TOTAL=$((LEGACY_TEST_FAILURES + LEGACY_BUILD_FAILURES))
                  TOTAL_UNIQUE_FAILURES=$((TOTAL_UNIQUE_FAILURES + LEGACY_TOTAL))
                  echo "  ‚Ä¢ Test failures: $LEGACY_TEST_FAILURES"
                  echo "  ‚Ä¢ Build failures: $LEGACY_BUILD_FAILURES"
                  echo "  ‚Ä¢ Total from this file: $LEGACY_TOTAL"
                fi
              done
              echo "üìä Legacy detection found: $TOTAL_UNIQUE_FAILURES total failures"
            else
              echo "‚ö†Ô∏è No legacy summary files found either"
            fi
          fi

          # Save deduplication stats for reporting
          jq -n --arg raw "$TOTAL_RAW_FAILURES" --arg unique "$TOTAL_UNIQUE_FAILURES" '{
            raw_failure_count: ($raw | tonumber),
            unique_failure_count: ($unique | tonumber),
            duplicates_eliminated: (($raw | tonumber) - ($unique | tonumber))
          }' > deduplication-stats.json

      # --------------------------------------------------------------------
      # Enhanced test results validation with deduplication
      # --------------------------------------------------------------------
      - name: üîç Validate test results
        run: |
          echo "üîç Validating test results using deduplicated failure analysis..."
          VALIDATION_FAILED=false
          TOTAL_TESTS=0

          # Load deduplication statistics
          RAW_FAILURES=0
          UNIQUE_FAILURES=0
          if [[ -f deduplication-stats.json ]]; then
            RAW_FAILURES=$(jq -r '.raw_failure_count // 0' deduplication-stats.json)
            UNIQUE_FAILURES=$(jq -r '.unique_failure_count // 0' deduplication-stats.json)
            DUPLICATES_ELIMINATED=$(jq -r '.duplicates_eliminated // 0' deduplication-stats.json)
          fi

          # Check regular test results for overall test counts and exit codes
          if compgen -G "test-results/test-stats-*.json" >/dev/null 2>&1; then
            echo "üìã Found test statistics files:"
            ls -la test-results/test-stats-*.json

            for stats_file in test-results/test-stats-*.json; do
              echo "üìä Checking $stats_file..."

              # Extract basic test results
              TEST_PASSED=$(jq -r '.test_passed // empty' "$stats_file")
              TEST_EXIT_CODE=$(jq -r '.test_exit_code // empty' "$stats_file")
              TEST_NAME=$(jq -r '.name // empty' "$stats_file")
              TEST_MODE=$(jq -r '.test_mode // "unknown"' "$stats_file")
              TEST_COUNT=$(jq -r '.test_count // 0' "$stats_file")

              echo "  ‚Ä¢ Test Suite: $TEST_NAME"
              echo "  ‚Ä¢ Mode: $TEST_MODE"
              echo "  ‚Ä¢ Tests: $TEST_COUNT"
              echo "  ‚Ä¢ Exit Code: $TEST_EXIT_CODE"
              echo "  ‚Ä¢ Passed: $TEST_PASSED"

              if [[ "$TEST_PASSED" == "false" ]] || [[ "$TEST_EXIT_CODE" != "0" ]]; then
                echo "‚ùå Test suite '$TEST_NAME' failed with exit code $TEST_EXIT_CODE"
                VALIDATION_FAILED=true
              else
                echo "‚úÖ Test suite '$TEST_NAME' passed"
              fi

              TOTAL_TESTS=$((TOTAL_TESTS + TEST_COUNT))
            done
          else
            echo "‚ö†Ô∏è No regular test statistics found"
          fi

          # Use deduplicated failure count as the authoritative failure count
          # If deduplication found failures, use that count
          # If deduplication failed but validation failed, use a fallback count
          if [[ $UNIQUE_FAILURES -gt 0 ]]; then
            TOTAL_FAILURES=$UNIQUE_FAILURES
            echo "‚úÖ Using deduplicated failure count: $TOTAL_FAILURES"
          elif [[ "$VALIDATION_FAILED" == "true" ]]; then
            # Count from legacy files if deduplication failed
            TOTAL_FAILURES=0
            if compgen -G "test-results/*test-failures-summary.json" >/dev/null 2>&1; then
              for summary_file in test-results/*test-failures-summary.json; do
                if [[ -s "$summary_file" ]]; then
                  echo "üìÑ Processing summary file: $summary_file for failure counting"

                  # Count test failures - handle both regular test format and fuzz test format
                  # Regular test format: .failures array contains individual test failures (excluding fuzz tests)
                  LEGACY_TEST_COUNT=$(jq '[.[] | select(.failures and ((.Type // null) != "test")) | .failures[]] | length' "$summary_file" 2>/dev/null || echo "0")

                  # Count fuzz test failures - fuzz tests have Type field and failures array
                  # This counts the number of individual test failures within fuzz test entries
                  FUZZ_TEST_FAILURES=$(jq '[.[] | select((.Type // null) == "test") | (.failures // [])[]] | length' "$summary_file" 2>/dev/null || echo "0")

                  # Count build failures
                  BUILD_COUNT=$(jq '[.[] | select((.Type // null) == "build")] | length' "$summary_file" 2>/dev/null || echo "0")

                  LEGACY_COUNT=$((LEGACY_TEST_COUNT + FUZZ_TEST_FAILURES))
                  TOTAL_FAILURES=$((TOTAL_FAILURES + LEGACY_COUNT + BUILD_COUNT))

                  echo "  ‚Ä¢ Test failures: $LEGACY_TEST_COUNT, Fuzz failures: $FUZZ_TEST_FAILURES, Build failures: $BUILD_COUNT"
                  echo "  ‚Ä¢ Total from this file: $((LEGACY_COUNT + BUILD_COUNT))"
                fi
              done
            fi
            # Fallback: if still 0 but validation failed, report at least 1 failure
            if [[ $TOTAL_FAILURES -eq 0 ]]; then
              TOTAL_FAILURES=1
              echo "‚ö†Ô∏è Using fallback failure count (validation failed but no specific failures counted)"
            else
              echo "‚úÖ Using legacy failure count: $TOTAL_FAILURES"
            fi
          else
            TOTAL_FAILURES=0
          fi

          # Check fuzz test results if enabled
          if [[ "${{ inputs.fuzz-testing-enabled }}" == "true" ]]; then
            if compgen -G "test-results/fuzz-stats-*.json" >/dev/null 2>&1; then
              echo "üìã Found fuzz test statistics files:"
              ls -la test-results/fuzz-stats-*.json

              for stats_file in test-results/fuzz-stats-*.json; do
                echo "üìä Checking $stats_file..."

                # Extract fuzz test results
                FUZZ_PASSED=$(jq -r '.test_passed // false' "$stats_file")
                FUZZ_EXIT_CODE=$(jq -r '.test_exit_code // empty' "$stats_file")
                FUZZ_NAME=$(jq -r '.name // empty' "$stats_file")

                echo "  ‚Ä¢ Fuzz Test: $FUZZ_NAME"
                echo "  ‚Ä¢ Exit Code: $FUZZ_EXIT_CODE"
                echo "  ‚Ä¢ Passed: $FUZZ_PASSED"

                if [[ "$FUZZ_PASSED" == "false" ]] || [[ "$FUZZ_EXIT_CODE" != "0" ]]; then
                  echo "‚ùå Fuzz test suite '$FUZZ_NAME' failed with exit code $FUZZ_EXIT_CODE"
                  VALIDATION_FAILED=true
                else
                  echo "‚úÖ Fuzz test suite '$FUZZ_NAME' passed"
                fi

                # Add fuzz test count to total
                FUZZ_TEST_COUNT=$(jq -r '.fuzz_test_count // 0' "$stats_file")
                echo "  ‚Ä¢ Fuzz Tests: $FUZZ_TEST_COUNT"
                TOTAL_TESTS=$((TOTAL_TESTS + FUZZ_TEST_COUNT))
              done
            else
              echo "‚ö†Ô∏è No fuzz test statistics found (fuzz testing was enabled)"
            fi
          fi

          # Fix: Update TOTAL_FAILURES if validation failed but we haven't counted any failures yet
          # This handles the case where fuzz tests failed but TOTAL_FAILURES is still 0
          if [[ "$VALIDATION_FAILED" == "true" ]] && [[ $TOTAL_FAILURES -eq 0 ]]; then
            echo "üîß Detected validation failure with 0 counted failures - recounting..."

            # Recount failures including fuzz test failures that were just detected
            if compgen -G "test-results/*test-failures-summary.json" >/dev/null 2>&1; then
              for summary_file in test-results/*test-failures-summary.json; do
                if [[ -s "$summary_file" ]]; then
                  echo "üìÑ Recounting failures from: $summary_file"

                  # Count all failure types
                  RECOUNT_TEST=$(jq '[.[] | select(.failures) | .failures[]] | length' "$summary_file" 2>/dev/null || echo "0")
                  RECOUNT_FUZZ=$(jq '[.[] | select((.Type // null) == "test") | (.failures // [])[]] | length' "$summary_file" 2>/dev/null || echo "0")
                  RECOUNT_BUILD=$(jq '[.[] | select((.Type // null) == "build")] | length' "$summary_file" 2>/dev/null || echo "0")

                  FILE_FAILURES=$((RECOUNT_TEST + RECOUNT_FUZZ + RECOUNT_BUILD))
                  TOTAL_FAILURES=$((TOTAL_FAILURES + FILE_FAILURES))

                  echo "  ‚Ä¢ Found $FILE_FAILURES failures in this file (test:$RECOUNT_TEST, fuzz:$RECOUNT_FUZZ, build:$RECOUNT_BUILD)"
                fi
              done
            fi

            # If still no failures found but validation failed, use fallback
            if [[ $TOTAL_FAILURES -eq 0 ]]; then
              TOTAL_FAILURES=1
              echo "‚ö†Ô∏è Using fallback count: validation failed but no structured failures found"
            else
              echo "‚úÖ Recount successful: found $TOTAL_FAILURES total failures"
            fi
          fi

          # Enhanced validation summary with deduplication info
          echo ""
          echo "üèÅ Validation Summary:"
          echo "  ‚Ä¢ Total Tests: $TOTAL_TESTS"
          echo "  ‚Ä¢ Unique Failures: $TOTAL_FAILURES"
          if [[ $RAW_FAILURES -gt 0 && $RAW_FAILURES -gt $UNIQUE_FAILURES ]]; then
            echo "  ‚Ä¢ Raw Reports: $RAW_FAILURES (eliminated $DUPLICATES_ELIMINATED duplicates)"
          fi

          # Display detailed failure information if tests failed
          if [[ "$VALIDATION_FAILED" == "true" ]]; then
            echo ""
            echo "üîç Detailed Failure Analysis (Deduplicated):"
            echo "==============================================="

            # Use deduplicated failures if available
            if [[ -f deduplicated-failures.json ]] && [[ $(jq 'length' deduplicated-failures.json 2>/dev/null || echo "0") -gt 0 ]]; then
              echo "üìã Found deduplicated failure details:"
              DEDUP_COUNT=$(jq 'length' deduplicated-failures.json)
              echo "  ‚Ä¢ Unique failures after deduplication: $DEDUP_COUNT"

              # Show build failures first
              BUILD_FAILURES=$(jq -r '.[] | select(.type == "build") | "  üî® " + (.package | split("/") | .[-1] // .[-2] // .) + ": Build compilation failed (" + (.occurrences | tostring) + " matrix jobs)"' deduplicated-failures.json 2>/dev/null)
              if [[ -n "$BUILD_FAILURES" ]]; then
                echo ""
                echo "üî® Build Failures:"
                echo "------------------"
                echo "$BUILD_FAILURES"

                # Show detailed build errors with output
                jq -r '.[] | select(.type == "build") |
                  "üì¶ " + (.package | split("/") | .[-1] // .[-2] // .) + " (detected in " + (.occurrences | tostring) + " matrix jobs):" +
                  "\n" + (.output // "No detailed error available")' deduplicated-failures.json 2>/dev/null | sed 's/^/  /' | head -c 2000
              fi

              # Show test failures with enhanced details
              TEST_FAILURES=$(jq -r '.[] | select(.type == "test" and (.test | startswith("Fuzz") | not)) |
                "  üì¶ " + (.package | split("/") | .[-1] // .[-2] // .) + ": " + .test + " (" + (.occurrences | tostring) + " matrix jobs)"' deduplicated-failures.json 2>/dev/null)
              if [[ -n "$TEST_FAILURES" ]]; then
                echo ""
                echo "üß™ Test Failures:"
                echo "-----------------"
                echo "$TEST_FAILURES"

                # Show detailed test outputs
                echo ""
                echo "üìù Test Error Details:"
                echo "---------------------"
                jq -r '.[] | select(.type == "test" and (.test | startswith("Fuzz") | not)) |
                  "‚ùå " + .test + " (" + (.package | split("/") | .[-1] // .[-2] // .) + "):" +
                  "\n" + (.output // "No error output available")' deduplicated-failures.json 2>/dev/null | head -c 3000
              fi

              # Show fuzz test failures with special formatting
              FUZZ_FAILURES=$(jq -r '.[] | select(.type == "test" and (.test | startswith("Fuzz"))) |
                "  üéØ " + (.package | split("/") | .[-1] // .[-2] // .) + ": " + .test + " (" + (.occurrences | tostring) + " matrix jobs)"' deduplicated-failures.json 2>/dev/null)
              if [[ -n "$FUZZ_FAILURES" ]]; then
                echo ""
                echo "üéØ Fuzz Test Failures:"
                echo "---------------------"
                echo "$FUZZ_FAILURES"

                # Show detailed fuzz test outputs with enhanced formatting
                echo ""
                echo "üìù Fuzz Test Error Details:"
                echo "--------------------------"
                jq -r '.[] | select(.type == "test" and (.test | startswith("Fuzz"))) |
                  "üéØ " + .test + " (" + (.package | split("/") | .[-1] // .[-2] // .) + "):" +
                  "\nüîç Error Output:" +
                  "\n" + (.output // "No fuzz test output available") +
                  "\n" +
                  (if (.output | contains("Failing input written to")) then
                    "\nüí° Re-run command: " + ((.output | split("\n")[] | select(. | contains("go test -run="))) // "Check output above for re-run command")
                   else "" end)' deduplicated-failures.json 2>/dev/null | head -c 4000
              fi

            # Fallback to old structured failure details
            elif compgen -G "test-results/*test-failures-summary.json" >/dev/null 2>&1; then
              echo "üìã Found legacy structured failure details:"
              for failure_file in test-results/*test-failures-summary.json; do
                echo ""
                echo "üìÑ Processing: $failure_file"

                # Extract and display package-level failures
                PACKAGES=$(jq -r 'length' "$failure_file" 2>/dev/null || echo "0")
                if [[ "$PACKAGES" -gt 0 ]]; then
                  echo "  ‚Ä¢ Affected Packages: $PACKAGES"

                  # Show package summary grouped by failure type
                  echo "üì¶ Package Summary:"

                  # Show build failures first
                  BUILD_PACKAGES=$(jq -r '.[] | select((.Type // null) == "build") | select(.Package | test("^[a-zA-Z0-9/_.-]+$")) | "  üî® \(.Package | split("/") | .[-1] // .[-2] // .): Build failed"' "$failure_file" 2>/dev/null || true)
                  if [[ -n "$BUILD_PACKAGES" ]]; then
                    echo "$BUILD_PACKAGES"
                  fi

                  # Show regular test failures
                  TEST_PACKAGES=$(jq -r '.[] | select((.Type // null) == null) | select(.Package | test("^[a-zA-Z0-9/_.-]+$")) | "  üì¶ \(.Package | split("/") | .[-1] // .[-2] // .): \(.failures | length) test failure(s)"' "$failure_file" 2>/dev/null || true)
                  if [[ -n "$TEST_PACKAGES" ]]; then
                    echo "$TEST_PACKAGES"
                  fi

                  # Show fuzz test failures
                  FUZZ_PACKAGES=$(jq -r '.[] | select((.Type // null) == "test") | select(.Package | test("^[a-zA-Z0-9/_.-]+$")) | "  üéØ \(.Package | split("/") | .[-1] // .[-2] // .): \(.failures | length) fuzz test failure(s)"' "$failure_file" 2>/dev/null || true)
                  if [[ -n "$FUZZ_PACKAGES" ]]; then
                    echo "$FUZZ_PACKAGES"
                  fi

                  # Show build failures in detail
                  BUILD_FAILURE_COUNT=$(jq -r '[.[] | select((.Type // null) == "build")] | length' "$failure_file" 2>/dev/null || echo "0")
                  if [[ "$BUILD_FAILURE_COUNT" -gt 0 ]]; then
                    echo ""
                    echo "üî® Build Failures:"
                    echo "------------------"

                    jq -r '.[] | select((.Type // null) == "build") | select(.Package | test("^[a-zA-Z0-9/_.-]+$")) |
                      "üì¶ " + (.Package | split("/") | .[-1] // .[-2] // .) + ":" +
                      ((.BuildErrors[]? // []) | "\n  ‚ùå " + .)' "$failure_file" 2>/dev/null || true
                  fi

                  # Show regular test failures
                  TEST_FAILURE_COUNT=$(jq -r '[.[] | select((.Type // null) == null)] | length' "$failure_file" 2>/dev/null || echo "0")
                  if [[ "$TEST_FAILURE_COUNT" -gt 0 ]]; then
                    echo ""
                    echo "üß™ Test Failures:"
                    echo "-----------------"

                    # Show detailed failed tests with package context (leaf failures only) - only for test failures
                    #
                    # Problem: Go's nested test structure (TestA/TestB/TestC) reports failures for
                    # all parent tests when a leaf test fails, causing confusing output like:
                    #   ‚ùå TestNetworkEdgeCases/concurrent_api_operations/concurrency_3 (integration) <- actual failure
                    #   ‚ùå TestNetworkEdgeCases/concurrent_api_operations (integration)              <- parent (redundant)
                    #   ‚ùå TestNetworkEdgeCases (integration)                                       <- parent (redundant)
                    #   ‚ùå  (integration)                                                           <- empty (artifact)
                    #
                    # Solution: Extract and deduplicate to show only the actual failed leaf tests
                    # This reduces "4 failures" to "1 actual failure" for better clarity.
                    RAW_FAILED_TESTS=$(jq -r '.[] as $parent | select(($parent.Type // null) == null) | select($parent.Package | test("^[a-zA-Z0-9/_.-]+$")) | $parent.failures[] | .Test + " (" + ($parent.Package | split("/") | .[-1] // .[-2] // .) + ")"' "$failure_file" 2>/dev/null)

                  # Smart filtering: Only show the most specific (deepest nested) test failures
                  FAILED_TESTS=$(echo "$RAW_FAILED_TESTS" | awk '
                    {
                      # Skip empty lines
                      if ($0 == "" || $0 ~ /^[[:space:]]*$/) next

                      # Extract test name before package info
                      if (match($0, /^([^(]*[^[:space:]]) \(.*\)$/)) {
                        testname = substr($0, RSTART, RLENGTH)
                        gsub(/ \(.*\)$/, "", testname)
                        # Remove leading/trailing whitespace
                        gsub(/^[[:space:]]+|[[:space:]]+$/, "", testname)
                        # Skip if testname is empty
                        if (testname == "") next

                        # Count depth by number of "/" characters
                        depth_counter = testname
                        gsub(/[^\/]/, "", depth_counter)
                        depth = length(depth_counter)
                        tests[NR] = $0
                        depths[NR] = depth
                        names[NR] = testname
                      }
                    }
                    END {
                      # For each test, check if there is a more specific (deeper) version
                      for (i in tests) {
                        is_leaf = 1
                        for (j in tests) {
                          if (i != j && depths[j] > depths[i] && index(names[j], names[i]) == 1) {
                            is_leaf = 0
                            break
                          }
                        }
                        if (is_leaf && names[i] != "") print tests[i]
                      }
                    }
                  ' | head -20)

                  if [[ -n "$FAILED_TESTS" ]]; then
                    echo "$FAILED_TESTS" | sed 's/^/  ‚ùå /'

                    # Update failure count to reflect actual unique failures
                    ACTUAL_UNIQUE_FAILURES=$(echo "$FAILED_TESTS" | grep -v '^[[:space:]]*$' | wc -l)
                    RAW_FAILURE_COUNT=$(echo "$RAW_FAILED_TESTS" | grep -v '^[[:space:]]*$' | wc -l)
                    if [[ $RAW_FAILURE_COUNT -gt $ACTUAL_UNIQUE_FAILURES ]]; then
                      echo ""
                      echo "  üìä Note: Showing $ACTUAL_UNIQUE_FAILURES actual failures"
                      echo "         (filtered from $RAW_FAILURE_COUNT nested test hierarchy entries)"
                    fi
                  else
                    echo "  ‚ö†Ô∏è No test failures found in JSON structure"
                    echo "  üìÑ Raw JSON content:"
                    head -c 2000 "$failure_file" | sed 's/^/  /'
                  fi

                    # Show any error outputs if available from the enhanced failure details (for test failures only)
                    ERROR_OUTPUTS=$(jq -r '.[] as $package | select(($package.Type // null) == null) | select($package.Package | test("^[a-zA-Z0-9/_.-]+$")) | $package.failures[] | select(.Output and .Output != "" and .Output != null) | "‚ùå \(.Test) (\($package.Package | split("/") | .[-1] // .[-2] // .))\n\(.Output)\n"' "$failure_file" 2>/dev/null | head -c 3000)
                    if [[ -n "$ERROR_OUTPUTS" ]]; then
                      echo ""
                      echo "üìù Test Error Messages:"
                      echo "----------------------"
                      echo "$ERROR_OUTPUTS"
                    fi
                  fi  # End of regular test failures section

                  # Show fuzz test failures
                  FUZZ_FAILURE_COUNT=$(jq -r '[.[] | select((.Type // null) == "test")] | length' "$failure_file" 2>/dev/null || echo "0")
                  if [[ "$FUZZ_FAILURE_COUNT" -gt 0 ]]; then
                    echo ""
                    echo "üéØ Fuzz Test Failures:"
                    echo "---------------------"

                    # Extract fuzz test failures
                    FUZZ_FAILED_TESTS=$(jq -r '.[] as $parent | select(($parent.Type // null) == "test") | select($parent.Package | test("^[a-zA-Z0-9/_.-]+$")) | $parent.failures[] | .Test + " (" + ($parent.Package | split("/") | .[-1] // .[-2] // .) + ")"' "$failure_file" 2>/dev/null)

                    if [[ -n "$FUZZ_FAILED_TESTS" ]]; then
                      echo "$FUZZ_FAILED_TESTS" | sed 's/^/  üéØ /'

                      # Show detailed fuzz test error outputs with re-run commands
                      FUZZ_ERROR_OUTPUTS=$(jq -r '.[] as $package | select(($package.Type // null) == "test") | select($package.Package | test("^[a-zA-Z0-9/_.-]+$")) | $package.failures[] | select(.Output and .Output != "" and .Output != null) |
                        "üéØ \(.Test) (\($package.Package | split("/") | .[-1] // .[-2] // .)):\nüîç Error Output:\n\(.Output)" +
                        (if (.Output | contains("Failing input written to")) then "\nüí° Re-run command: Check output above for re-run command" else "" end) + "\n"' "$failure_file" 2>/dev/null | head -c 4000)

                      if [[ -n "$FUZZ_ERROR_OUTPUTS" ]]; then
                        echo ""
                        echo "üìù Fuzz Test Error Details:"
                        echo "--------------------------"
                        echo "$FUZZ_ERROR_OUTPUTS"
                      fi
                    else
                      echo "  ‚ö†Ô∏è No fuzz test failures found in JSON structure"
                    fi
                  fi  # End of fuzz test failures section
                else
                  echo "  ‚Ä¢ No structured failure data found in JSON"
                fi
              done

            # Fallback to simple text files if JSON not available
            elif compgen -G "test-results/*test-failures.txt" >/dev/null 2>&1; then
              echo "üìã Found text failure details:"
              for failure_file in test-results/*test-failures.txt; do
                if [[ -s "$failure_file" ]]; then
                  echo ""
                  echo "üìÑ Processing: $failure_file"
                  echo "üö® Failed Tests:"
                  echo "---------------"
                  head -20 "$failure_file" | while IFS= read -r line; do
                    echo "  ‚ùå $line"
                  done
                fi
              done

            else
              echo "‚ö†Ô∏è No detailed failure information found in downloaded artifacts"
              echo "   Available files:"
              ls -la test-results/ 2>/dev/null | head -10 || echo "   No files found"
            fi

            echo ""
            echo "==============================================="
            if [[ $RAW_FAILURES -gt $UNIQUE_FAILURES ]]; then
              echo "‚ùå Test validation failed - $TOTAL_FAILURES unique failure(s) (from $RAW_FAILURES reports across matrix jobs)"
              echo "::error title=Test Validation Failed::$TOTAL_FAILURES unique test failure(s) detected (eliminated $DUPLICATES_ELIMINATED duplicates from $RAW_FAILURES total reports). Check deduplicated failure analysis above."
            else
              echo "‚ùå Test validation failed - $TOTAL_FAILURES test(s) failed"
              echo "::error title=Test Validation Failed::$TOTAL_FAILURES test(s) failed across all test suites. Check failure details above."
            fi
            exit 1
          else
            echo "‚úÖ All $TOTAL_TESTS tests passed validation"
          fi

      # --------------------------------------------------------------------
      # Create validation summary for GitHub UI with deduplication info
      # --------------------------------------------------------------------
      - name: üìä Create validation summary
        if: always()
        run: |
          echo "## üîç Test Validation Summary (With Deduplication)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Load deduplication stats for summary
          if [[ -f deduplication-stats.json ]]; then
            RAW_COUNT=$(jq -r '.raw_failure_count // 0' deduplication-stats.json)
            UNIQUE_COUNT=$(jq -r '.unique_failure_count // 0' deduplication-stats.json)
            ELIMINATED_COUNT=$(jq -r '.duplicates_eliminated // 0' deduplication-stats.json)

            if [[ $RAW_COUNT -gt $UNIQUE_COUNT ]]; then
              echo "### üéØ Deduplication Results" >> $GITHUB_STEP_SUMMARY
              echo "- **Raw Failure Reports**: $RAW_COUNT" >> $GITHUB_STEP_SUMMARY
              echo "- **Unique Failures**: $UNIQUE_COUNT" >> $GITHUB_STEP_SUMMARY
              echo "- **Duplicates Eliminated**: $ELIMINATED_COUNT" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
            fi
          fi

          # Count test suites and statistics (using reliable file counting)
          TEST_SUITE_COUNT=0
          if ls test-results/test-stats-*.json >/dev/null 2>&1; then
            TEST_SUITE_COUNT=$(ls test-results/test-stats-*.json | wc -l)
          fi

          FUZZ_SUITE_COUNT=0
          if [[ "${{ inputs.fuzz-testing-enabled }}" == "true" ]]; then
            if ls test-results/fuzz-stats-*.json >/dev/null 2>&1; then
              FUZZ_SUITE_COUNT=$(ls test-results/fuzz-stats-*.json | wc -l)
            fi
          fi

          # Calculate total test counts across all suites
          TOTAL_REGULAR_TESTS=0
          TOTAL_FUZZ_TESTS=0

          # Aggregate regular test counts
          if [[ $TEST_SUITE_COUNT -gt 0 ]]; then
            for stats_file in test-results/test-stats-*.json; do
              if [[ -f "$stats_file" ]]; then
                TEST_COUNT=$(jq -r '.test_count // 0' "$stats_file")
                TOTAL_REGULAR_TESTS=$((TOTAL_REGULAR_TESTS + TEST_COUNT))
              fi
            done
          fi

          # Aggregate fuzz test counts
          if [[ $FUZZ_SUITE_COUNT -gt 0 ]]; then
            for stats_file in test-results/fuzz-stats-*.json; do
              if [[ -f "$stats_file" ]]; then
                FUZZ_COUNT=$(jq -r '.fuzz_test_count // 0' "$stats_file")
                TOTAL_FUZZ_TESTS=$((TOTAL_FUZZ_TESTS + FUZZ_COUNT))
              fi
            done
          fi

          echo "- **Test Matrix Jobs**: $TEST_SUITE_COUNT" >> $GITHUB_STEP_SUMMARY
          echo "- **Total Tests**: $TOTAL_REGULAR_TESTS" >> $GITHUB_STEP_SUMMARY
          echo "- **Fuzz Test Jobs**: $FUZZ_SUITE_COUNT" >> $GITHUB_STEP_SUMMARY
          echo "- **Total Fuzz Tests**: $TOTAL_FUZZ_TESTS" >> $GITHUB_STEP_SUMMARY
          echo "- **Validation Status**: ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Show per-suite breakdown if statistics available
          if [[ $TEST_SUITE_COUNT -gt 0 ]]; then
            echo "### Test Suite Breakdown" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            for stats_file in test-results/test-stats-*.json; do
              if [[ -f "$stats_file" ]]; then
                TEST_NAME=$(jq -r '.name // "Unknown"' "$stats_file")
                TEST_PASSED=$(jq -r '.test_passed // false' "$stats_file")
                TEST_COUNT=$(jq -r '.test_count // 0' "$stats_file")
                FAILURES=$(jq -r '.total_failures // 0' "$stats_file")

                if [[ "$TEST_PASSED" == "true" ]]; then
                  echo "- ‚úÖ **$TEST_NAME**: $TEST_COUNT tests passed" >> $GITHUB_STEP_SUMMARY
                else
                  echo "- ‚ùå **$TEST_NAME**: $FAILURES/$TEST_COUNT tests failed" >> $GITHUB_STEP_SUMMARY
                fi
              fi
            done
          fi

          if [[ $FUZZ_SUITE_COUNT -gt 0 ]]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Fuzz Test Breakdown" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            for stats_file in test-results/fuzz-stats-*.json; do
              if [[ -f "$stats_file" ]]; then
                FUZZ_NAME=$(jq -r '.name // "Unknown"' "$stats_file")
                FUZZ_PASSED=$(jq -r '.test_passed // false' "$stats_file")
                FUZZ_COUNT=$(jq -r '.fuzz_test_count // 0' "$stats_file")

                if [[ "$FUZZ_PASSED" == "true" ]]; then
                  echo "- ‚úÖ **$FUZZ_NAME**: $FUZZ_COUNT fuzz tests passed" >> $GITHUB_STEP_SUMMARY
                else
                  echo "- ‚ùå **$FUZZ_NAME**: Fuzz tests failed" >> $GITHUB_STEP_SUMMARY
                fi
              fi
            done
          fi

      # --------------------------------------------------------------------
      # Upload validation artifacts for completion report
      # --------------------------------------------------------------------
      - name: üì§ Upload validation summary
        if: always()
        uses: actions/upload-artifact@330a01c490aca151604b8cf639adc76d48f6c5d4 # v5.0.0
        with:
          name: validation-summary
          path: |
            test-results/
            deduplicated-failures.json
            deduplication-stats.json
          retention-days: 1
          if-no-files-found: ignore
