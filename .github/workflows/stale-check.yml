# ------------------------------------------------------------------------------------
#  Stale Check Workflow
#
#  Purpose: Warn about and close inactive issues and PRs to maintain repository hygiene.
#  This workflow identifies stale items, marks them with a label, and eventually closes
#  them if no activity occurs within the configured timeframe.
#
#  Configuration: All settings are loaded from .env.base and .env.custom files for
#  centralized management across all workflows.
#
#  Triggers:
#  - Scheduled: Monday-Friday at 08:32 UTC
#  - Manual: Via workflow_dispatch
#
#  Maintainer: @mrz1836
#
# ------------------------------------------------------------------------------------

name: Stale Check

# --------------------------------------------------------------------
# Trigger Configuration
# --------------------------------------------------------------------
on:
  schedule:
    # ‚îå‚îÄ min  ‚îÄ‚î¨‚îÄ hour ‚îÄ‚î¨‚îÄ dom ‚îÄ‚î¨‚îÄ mon ‚îÄ‚î¨‚îÄ dow ‚îÄ‚îê
    - cron: "0 12 * * 1-5" # 7:00 AM EST (12:00 UTC)
  workflow_dispatch: # Allow manual triggering

# Security: Restrictive default permissions with job-level overrides for least privilege access
permissions:
  contents: read

# --------------------------------------------------------------------
# Concurrency Control
# --------------------------------------------------------------------
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # ----------------------------------------------------------------------------------
  # Load Environment Variables
  # ----------------------------------------------------------------------------------
  load-env:
    name: üåç Load Environment Variables
    runs-on: ubuntu-latest
    outputs:
      env-json: ${{ steps.load-env.outputs.env-json }}
    steps:
      # --------------------------------------------------------------------
      # Check out code to access env file
      # --------------------------------------------------------------------
      - name: üì• Checkout code (sparse)
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          sparse-checkout: |
            .github/.env.base
            .github/.env.custom
            .github/actions/load-env

      # --------------------------------------------------------------------
      # Load and parse environment file
      # --------------------------------------------------------------------
      - name: üåç Load environment variables
        uses: ./.github/actions/load-env
        id: load-env

  # ----------------------------------------------------------------------------------
  # Main Stale Check Job
  # ----------------------------------------------------------------------------------
  stale-check:
    name: üßπ Process Stale Items
    needs: [load-env]
    runs-on: ubuntu-latest
    permissions:
      issues: write # Required to add labels and comments
      pull-requests: write # Required to add labels and comments on PRs

    steps:
      # --------------------------------------------------------------------
      # Log token configuration
      # --------------------------------------------------------------------
      - name: üîë Log token configuration
        env:
          ENV_JSON: ${{ needs.load-env.outputs.env-json }}
        run: |
          PREFERRED_TOKEN=$(echo "$ENV_JSON" | jq -r '.PREFERRED_GITHUB_TOKEN')

          if [[ "$PREFERRED_TOKEN" == "GH_PAT_TOKEN" && -n "${{ secrets.GH_PAT_TOKEN }}" ]]; then
            echo "‚úÖ Using Personal Access Token (PAT) for stale check operations"
          else
            echo "‚úÖ Using default GITHUB_TOKEN for stale check operations"
          fi

      # --------------------------------------------------------------------
      # Extract environment variables
      # --------------------------------------------------------------------
      - name: üîß Extract stale configuration
        id: config
        env:
          ENV_JSON: ${{ needs.load-env.outputs.env-json }}
        run: |
          echo "üéØ Extracting stale workflow configuration..."

          # Extract stale-specific variables from JSON
          DAYS_BEFORE_STALE=$(echo "$ENV_JSON" | jq -r '.STALE_DAYS_BEFORE_STALE')
          DAYS_BEFORE_CLOSE=$(echo "$ENV_JSON" | jq -r '.STALE_DAYS_BEFORE_CLOSE')
          STALE_LABEL=$(echo "$ENV_JSON" | jq -r '.STALE_LABEL')
          EXEMPT_ISSUE_LABELS=$(echo "$ENV_JSON" | jq -r '.STALE_EXEMPT_ISSUE_LABELS')
          EXEMPT_PR_LABELS=$(echo "$ENV_JSON" | jq -r '.STALE_EXEMPT_PR_LABELS')
          OPERATIONS_PER_RUN=$(echo "$ENV_JSON" | jq -r '.STALE_OPERATIONS_PER_RUN')

          # Export to outputs
          echo "days-before-stale=$DAYS_BEFORE_STALE" >> $GITHUB_OUTPUT
          echo "days-before-close=$DAYS_BEFORE_CLOSE" >> $GITHUB_OUTPUT
          echo "stale-label=$STALE_LABEL" >> $GITHUB_OUTPUT
          echo "exempt-issue-labels=$EXEMPT_ISSUE_LABELS" >> $GITHUB_OUTPUT
          echo "exempt-pr-labels=$EXEMPT_PR_LABELS" >> $GITHUB_OUTPUT
          echo "operations-per-run=$OPERATIONS_PER_RUN" >> $GITHUB_OUTPUT

          echo "‚úÖ Configuration extracted successfully"

      # --------------------------------------------------------------------
      # Calculate cutoff dates for stale detection
      # --------------------------------------------------------------------
      - name: üìÖ Calculate cutoff dates
        id: dates
        run: |
          echo "‚è±Ô∏è Calculating stale and close cutoff dates..."

          # Calculate dates for stale marking and closing
          DAYS_BEFORE_STALE="${{ steps.config.outputs.days-before-stale }}"
          DAYS_BEFORE_CLOSE="${{ steps.config.outputs.days-before-close }}"

          stale_date=$(date -d "$DAYS_BEFORE_STALE days ago" --iso-8601)
          close_date=$(date -d "$(( $DAYS_BEFORE_STALE + $DAYS_BEFORE_CLOSE )) days ago" --iso-8601)

          echo "stale_cutoff=${stale_date}" >> $GITHUB_OUTPUT
          echo "close_cutoff=${close_date}" >> $GITHUB_OUTPUT

          echo "üìä === Stale Check Configuration ==="
          echo "üî∏ Stale cutoff date: ${stale_date} (${DAYS_BEFORE_STALE} days ago)"
          echo "üî∏ Close cutoff date: ${close_date} ($(( ${DAYS_BEFORE_STALE} + ${DAYS_BEFORE_CLOSE} )) days ago)"
          echo "üî∏ Stale label: ${{ steps.config.outputs.stale-label }}"
          echo "üî∏ Operations limit: ${{ steps.config.outputs.operations-per-run }}"
          echo "‚úÖ Date calculations complete"

      # --------------------------------------------------------------------
      # Process issues for stale marking and closing
      # --------------------------------------------------------------------
      - name: üìã Process stale issues
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        env:
          ENV_JSON: ${{ needs.load-env.outputs.env-json }}
        with:
          github-token: ${{ secrets.GH_PAT_TOKEN != '' && secrets.GH_PAT_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const staleCutoff = '${{ steps.dates.outputs.stale_cutoff }}';
            const closeCutoff = '${{ steps.dates.outputs.close_cutoff }}';
            const staleLabel = '${{ steps.config.outputs.stale-label }}';
            const exemptLabels = '${{ steps.config.outputs.exempt-issue-labels }}'.split(',').map(l => l.trim()).filter(l => l);
            const operationsLimit = parseInt('${{ steps.config.outputs.operations-per-run }}');
            const daysBeforeClose = parseInt('${{ steps.config.outputs.days-before-close }}');
            const envJson = JSON.parse(process.env.ENV_JSON);
            const preferredToken = envJson.PREFERRED_GITHUB_TOKEN;
            const isUsingPAT = preferredToken === 'GH_PAT_TOKEN' && '${{ secrets.GH_PAT_TOKEN }}' !== '';

            console.log('üìã === Processing Issues ===');
            console.log(`üè∑Ô∏è Exempt labels: ${exemptLabels.join(', ')}`);
            console.log(`üîë Token type: ${isUsingPAT ? 'Personal Access Token (PAT)' : 'Default GITHUB_TOKEN'}`);

            let operationsCount = 0;
            let processedCount = 0;
            let markedStaleCount = 0;
            let closedCount = 0;

            // Helper function to check if issue has exempt labels
            function hasExemptLabel(issue) {
              const issueLabels = issue.labels.map(label => label.name);
              return exemptLabels.some(exempt => issueLabels.includes(exempt));
            }

            // Helper function to check if issue is already stale
            function isAlreadyStale(issue) {
              return issue.labels.some(label => label.name === staleLabel);
            }

            // Get all open issues with pagination
            const iterator = github.paginate.iterator(github.rest.issues.listForRepo, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              sort: 'updated',
              direction: 'asc',
              per_page: 100
            });

            for await (const { data: issues } of iterator) {
              for (const issue of issues) {
                // Skip pull requests (they're handled separately)
                if (issue.pull_request) continue;

                // Stop if we've hit our operations limit
                if (operationsCount >= operationsLimit) {
                  console.log(`‚ö†Ô∏è Reached operations limit (${operationsLimit}), stopping`);
                  break;
                }

                processedCount++;
                const updatedAt = new Date(issue.updated_at);
                const daysSinceUpdate = Math.floor((Date.now() - updatedAt.getTime()) / (1000 * 60 * 60 * 24));

                console.log(`üîç Processing issue #${issue.number}: "${issue.title}" (updated ${daysSinceUpdate} days ago)`);

                // Skip if issue has exempt labels
                if (hasExemptLabel(issue)) {
                  console.log(`  ‚è≠Ô∏è Skipping: has exempt label`);
                  continue;
                }

                const alreadyStale = isAlreadyStale(issue);

                // Check if issue should be closed (already stale + past close cutoff)
                if (alreadyStale && updatedAt < new Date(closeCutoff)) {
                  try {
                    await github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issue.number,
                      body: `This issue was automatically closed after **${daysSinceUpdate} days** of inactivity. If this is still relevant, feel free to re-open.`
                    });

                    await github.rest.issues.update({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issue.number,
                      state: 'closed'
                    });

                    console.log(`  ‚úÖ Closed issue #${issue.number}`);
                    closedCount++;
                    operationsCount += 2;
                  } catch (error) {
                    console.log(`  ‚ùå Failed to close issue #${issue.number}: ${error.message}`);
                  }
                }
                // Check if issue should be marked as stale
                else if (!alreadyStale && updatedAt < new Date(staleCutoff)) {
                  try {
                    await github.rest.issues.addLabels({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issue.number,
                      labels: [staleLabel]
                    });

                    await github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issue.number,
                      body: `This issue has been inactive for **${daysSinceUpdate} days** and will be closed in ${daysBeforeClose} days if no further activity occurs.`
                    });

                    console.log(`  üè∑Ô∏è Marked issue #${issue.number} as stale`);
                    markedStaleCount++;
                    operationsCount += 2;
                  } catch (error) {
                    console.log(`  ‚ùå Failed to mark issue #${issue.number} as stale: ${error.message}`);
                  }
                }
                else {
                  console.log(`  ‚úÖ Issue #${issue.number} is still active`);
                }
              }

              if (operationsCount >= operationsLimit) break;
            }

            console.log('\nüìä === Issues Summary ===');
            console.log(`‚úÖ Processed: ${processedCount} issues`);
            console.log(`üè∑Ô∏è Marked stale: ${markedStaleCount} issues`);
            console.log(`üîí Closed: ${closedCount} issues`);
            console.log(`‚ö° Operations used: ${operationsCount}/${operationsLimit}`);

      # --------------------------------------------------------------------
      # Process pull requests for stale marking and closing
      # --------------------------------------------------------------------
      - name: üîÄ Process stale pull requests
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        env:
          ENV_JSON: ${{ needs.load-env.outputs.env-json }}
        with:
          github-token: ${{ secrets.GH_PAT_TOKEN != '' && secrets.GH_PAT_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const staleCutoff = '${{ steps.dates.outputs.stale_cutoff }}';
            const closeCutoff = '${{ steps.dates.outputs.close_cutoff }}';
            const staleLabel = '${{ steps.config.outputs.stale-label }}';
            const exemptLabels = '${{ steps.config.outputs.exempt-pr-labels }}'.split(',').map(l => l.trim()).filter(l => l);
            const operationsLimit = parseInt('${{ steps.config.outputs.operations-per-run }}');
            const daysBeforeClose = parseInt('${{ steps.config.outputs.days-before-close }}');

            console.log('\nüîÄ === Processing Pull Requests ===');
            console.log(`üè∑Ô∏è Exempt labels: ${exemptLabels.join(', ')}`);

            let operationsCount = 0;
            let processedCount = 0;
            let markedStaleCount = 0;
            let closedCount = 0;

            // Helper functions (same as issues)
            function hasExemptLabel(pr) {
              const prLabels = pr.labels.map(label => label.name);
              return exemptLabels.some(exempt => prLabels.includes(exempt));
            }

            function isAlreadyStale(pr) {
              return pr.labels.some(label => label.name === staleLabel);
            }

            // Get all open pull requests with pagination
            const iterator = github.paginate.iterator(github.rest.pulls.list, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              sort: 'updated',
              direction: 'asc',
              per_page: 100
            });

            for await (const { data: prs } of iterator) {
              for (const pr of prs) {
                // Stop if we've hit our operations limit
                if (operationsCount >= operationsLimit) {
                  console.log(`‚ö†Ô∏è Reached operations limit (${operationsLimit}), stopping`);
                  break;
                }

                processedCount++;
                const updatedAt = new Date(pr.updated_at);
                const daysSinceUpdate = Math.floor((Date.now() - updatedAt.getTime()) / (1000 * 60 * 60 * 24));

                console.log(`üîç Processing PR #${pr.number}: "${pr.title}" (updated ${daysSinceUpdate} days ago)`);

                // Skip draft PRs
                if (pr.draft) {
                  console.log(`  ‚è≠Ô∏è Skipping: draft PR`);
                  continue;
                }

                // Skip if PR has exempt labels
                if (hasExemptLabel(pr)) {
                  console.log(`  ‚è≠Ô∏è Skipping: has exempt label`);
                  continue;
                }

                const alreadyStale = isAlreadyStale(pr);

                // Check if PR should be closed (already stale + past close cutoff)
                if (alreadyStale && updatedAt < new Date(closeCutoff)) {
                  try {
                    await github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: pr.number,
                      body: `This PR was automatically closed after **${daysSinceUpdate} days** of inactivity. If you plan to resume work, please re-open.`
                    });

                    await github.rest.pulls.update({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      pull_number: pr.number,
                      state: 'closed'
                    });

                    console.log(`  ‚úÖ Closed PR #${pr.number}`);
                    closedCount++;
                    operationsCount += 2;
                  } catch (error) {
                    console.log(`  ‚ùå Failed to close PR #${pr.number}: ${error.message}`);
                  }
                }
                // Check if PR should be marked as stale
                else if (!alreadyStale && updatedAt < new Date(staleCutoff)) {
                  try {
                    await github.rest.issues.addLabels({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: pr.number,
                      labels: [staleLabel]
                    });

                    await github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: pr.number,
                      body: `This pull request has been inactive for **${daysSinceUpdate} days** and will be closed in ${daysBeforeClose} days if no further activity occurs.`
                    });

                    console.log(`  üè∑Ô∏è Marked PR #${pr.number} as stale`);
                    markedStaleCount++;
                    operationsCount += 2;
                  } catch (error) {
                    console.log(`  ‚ùå Failed to mark PR #${pr.number} as stale: ${error.message}`);
                  }
                }
                else {
                  console.log(`  ‚úÖ PR #${pr.number} is still active`);
                }
              }

              if (operationsCount >= operationsLimit) break;
            }

            console.log('\nüìä === Pull Requests Summary ===');
            console.log(`‚úÖ Processed: ${processedCount} PRs`);
            console.log(`üè∑Ô∏è Marked stale: ${markedStaleCount} PRs`);
            console.log(`üîí Closed: ${closedCount} PRs`);
            console.log(`‚ö° Operations used: ${operationsCount}/${operationsLimit}`);

      # --------------------------------------------------------------------
      # Clean up stale labels from recently updated items
      # --------------------------------------------------------------------
      - name: üè∑Ô∏è Remove stale labels from updated items
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        with:
          github-token: ${{ secrets.GH_PAT_TOKEN != '' && secrets.GH_PAT_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const staleCutoff = new Date('${{ steps.dates.outputs.stale_cutoff }}');
            const staleLabel = '${{ steps.config.outputs.stale-label }}';

            console.log('\nüè∑Ô∏è === Cleaning Stale Labels ===');
            console.log('üîç Looking for recently updated items with stale labels...');

            let removedCount = 0;
            let checkedCount = 0;

            // Helper function to check if item should have stale label removed
            function shouldRemoveStaleLabel(item) {
              const updatedAt = new Date(item.updated_at);
              return updatedAt > staleCutoff;
            }

            // Process issues with stale label
            console.log('üìã Checking issues...');
            const issuesIterator = github.paginate.iterator(github.rest.issues.listForRepo, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: staleLabel,
              per_page: 100
            });

            for await (const { data: issues } of issuesIterator) {
              for (const issue of issues) {
                // Skip pull requests (they're handled separately)
                if (issue.pull_request) continue;

                checkedCount++;

                if (shouldRemoveStaleLabel(issue)) {
                  try {
                    await github.rest.issues.removeLabel({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issue.number,
                      name: staleLabel
                    });

                    console.log(`  ‚úÖ Removed stale label from issue #${issue.number}: "${issue.title}"`);
                    removedCount++;
                  } catch (error) {
                    if (error.status === 404) {
                      console.log(`  ‚ÑπÔ∏è Label not found on issue #${issue.number} (already removed)`);
                    } else {
                      console.log(`  ‚ùå Failed to remove stale label from issue #${issue.number}: ${error.message}`);
                    }
                  }
                }
              }
            }

            // Process pull requests with stale label
            console.log('\nüîÄ Checking pull requests...');
            const prsIterator = github.paginate.iterator(github.rest.pulls.list, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              per_page: 100
            });

            for await (const { data: prs } of prsIterator) {
              for (const pr of prs) {
                // Check if PR has stale label
                const prDetails = await github.rest.pulls.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: pr.number
                });

                const hasStaleLabel = prDetails.data.labels.some(label => label.name === staleLabel);

                if (hasStaleLabel) {
                  checkedCount++;

                  if (shouldRemoveStaleLabel(pr)) {
                    try {
                      await github.rest.issues.removeLabel({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        issue_number: pr.number,
                        name: staleLabel
                      });

                      console.log(`  ‚úÖ Removed stale label from PR #${pr.number}: "${pr.title}"`);
                      removedCount++;
                    } catch (error) {
                      if (error.status === 404) {
                        console.log(`  ‚ÑπÔ∏è Label not found on PR #${pr.number} (already removed)`);
                      } else {
                        console.log(`  ‚ùå Failed to remove stale label from PR #${pr.number}: ${error.message}`);
                      }
                    }
                  }
                }
              }
            }

            console.log(`\nüìä === Label Cleanup Summary ===`);
            console.log(`üîç Checked: ${checkedCount} items with stale label`);
            console.log(`‚úÖ Removed stale labels from: ${removedCount} items`);

      # --------------------------------------------------------------------
      # Generate a workflow summary report
      # --------------------------------------------------------------------
      - name: üìä Generate workflow summary
        env:
          ENV_JSON: ${{ needs.load-env.outputs.env-json }}
        run: |
          echo "üöÄ Generating workflow summary..."

          # Determine which token was used
          PREFERRED_TOKEN=$(echo "$ENV_JSON" | jq -r '.PREFERRED_GITHUB_TOKEN')
          if [[ "$PREFERRED_TOKEN" == "GH_PAT_TOKEN" && -n "${{ secrets.GH_PAT_TOKEN }}" ]]; then
            TOKEN_TYPE="üîë Personal Access Token (PAT)"
          else
            TOKEN_TYPE="üîë Default GITHUB_TOKEN"
          fi

          echo "# üßπ Stale Check Workflow Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**‚è∞ Completed:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "## ‚öôÔ∏è Configuration" >> $GITHUB_STEP_SUMMARY
          echo "| Setting | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Days before stale | ${{ steps.config.outputs.days-before-stale }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Days before close | ${{ steps.config.outputs.days-before-close }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Stale label | ${{ steps.config.outputs.stale-label }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Operations limit | ${{ steps.config.outputs.operations-per-run }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Token type | $TOKEN_TYPE |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "## üè∑Ô∏è Exempt Labels" >> $GITHUB_STEP_SUMMARY
          echo "- **Issues:** ${{ steps.config.outputs.exempt-issue-labels }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Pull Requests:** ${{ steps.config.outputs.exempt-pr-labels }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "üìã _Check the job logs above for detailed processing statistics._" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "‚úÖ **Stale check workflow completed successfully!**" >> $GITHUB_STEP_SUMMARY
